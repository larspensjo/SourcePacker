use crate::core::{
    self, ArchiveStatus, ArchiverOperations, ConfigError, ConfigManagerOperations, FileNode,
    FileState, FileSystemScannerOperations, Profile, ProfileError, ProfileManagerOperations,
    StateManagerOperations,
};
use crate::platform_layer::{
    AppEvent, CheckState, MessageSeverity, PlatformCommand, PlatformEventHandler,
    TreeItemDescriptor, TreeItemId, WindowId,
};
use std::collections::{HashMap, HashSet, VecDeque};
use std::path::{Path, PathBuf};
use std::sync::Arc;

pub const ID_BUTTON_GENERATE_ARCHIVE_LOGIC: i32 = 1002;
// Made pub(crate) for access from handler_tests.rs
pub(crate) const APP_NAME_FOR_PROFILES: &str = "SourcePacker";

type PathToTreeItemIdMap = HashMap<PathBuf, TreeItemId>;

// Made pub(crate) for access from handler_tests.rs
#[derive(Debug, PartialEq)]
pub(crate) enum PendingAction {
    SavingArchive,
    SavingProfile,
    CreatingNewProfileGetName,
    CreatingNewProfileGetRoot,
    SettingArchivePath,
}

/*
 * Manages the core application state and UI logic in a platform-agnostic manner.
 * It processes UI events received from the platform layer and generates commands
 * to update the UI. It depends on `ConfigManagerOperations` for app configuration,
 * `ProfileManagerOperations` for profile data, `FileSystemScannerOperations`
 * for directory scanning, `ArchiverOperations` for archiving, and
 * `StateManagerOperations` for tree state management.
 * Commands generated by event handlers are enqueued internally and retrieved by
 * the platform layer.
 */
pub struct MyAppLogic {
    main_window_id: Option<WindowId>,
    file_nodes_cache: Vec<FileNode>,
    path_to_tree_item_id: PathToTreeItemIdMap,
    next_tree_item_id_counter: u64,
    root_path_for_scan: PathBuf,
    current_profile_name: Option<String>,
    current_profile_cache: Option<Profile>,
    current_archive_status: Option<ArchiveStatus>,
    pending_action: Option<PendingAction>,
    pending_new_profile_name: Option<String>,
    config_manager: Arc<dyn ConfigManagerOperations>,
    profile_manager: Arc<dyn ProfileManagerOperations>,
    file_system_scanner: Arc<dyn FileSystemScannerOperations>,
    archiver: Arc<dyn ArchiverOperations>,
    state_manager: Arc<dyn StateManagerOperations>,
    synchronous_command_queue: VecDeque<PlatformCommand>,
}

impl MyAppLogic {
    /*
     * Initializes a new instance of the application logic.
     * Requires implementations for `ConfigManagerOperations` (app config),
     * `ProfileManagerOperations` (profile data), `FileSystemScannerOperations` (directory scanning),
     * `ArchiverOperations` (archiving), and `StateManagerOperations` (tree state management).
     * Sets up default application states and an empty command queue.
     */
    pub fn new(
        config_manager: Arc<dyn ConfigManagerOperations>,
        profile_manager: Arc<dyn ProfileManagerOperations>,
        file_system_scanner: Arc<dyn FileSystemScannerOperations>,
        archiver: Arc<dyn ArchiverOperations>,
        state_manager: Arc<dyn StateManagerOperations>,
    ) -> Self {
        MyAppLogic {
            main_window_id: None,
            file_nodes_cache: Vec::new(),
            path_to_tree_item_id: HashMap::new(),
            next_tree_item_id_counter: 1,
            root_path_for_scan: PathBuf::from("."),
            current_profile_name: None,
            current_profile_cache: None,
            current_archive_status: None,
            pending_action: None,
            pending_new_profile_name: None,
            config_manager,
            profile_manager,
            file_system_scanner,
            archiver,
            state_manager,
            synchronous_command_queue: VecDeque::new(),
        }
    }

    fn generate_tree_item_id(&mut self) -> TreeItemId {
        let id = self.next_tree_item_id_counter;
        self.next_tree_item_id_counter += 1;
        TreeItemId(id)
    }

    pub(crate) fn build_tree_item_descriptors_recursive(&mut self) -> Vec<TreeItemDescriptor> {
        return Self::build_tree_item_descriptors_recursive_internal(
            &self.file_nodes_cache,
            &mut self.path_to_tree_item_id,
            &mut self.next_tree_item_id_counter,
        );
    }

    fn build_tree_item_descriptors_recursive_internal(
        nodes: &[FileNode],
        path_to_tree_item_id: &mut PathToTreeItemIdMap,
        next_tree_item_id_counter: &mut u64,
    ) -> Vec<TreeItemDescriptor> {
        let mut descriptors = Vec::new();
        for node in nodes {
            let id_val = *next_tree_item_id_counter;
            *next_tree_item_id_counter += 1;
            let item_id = TreeItemId(id_val);

            path_to_tree_item_id.insert(node.path.clone(), item_id);

            let descriptor = TreeItemDescriptor {
                id: item_id,
                text: node.name.clone(),
                is_folder: node.is_dir,
                state: match node.state {
                    FileState::Selected => CheckState::Checked,
                    _ => CheckState::Unchecked,
                },
                children: Self::build_tree_item_descriptors_recursive_internal(
                    &node.children,
                    path_to_tree_item_id,
                    next_tree_item_id_counter,
                ),
            };
            descriptors.push(descriptor);
        }
        descriptors
    }

    /*
     * Handles the event indicating the main application window has been created.
     * It attempts to load the last used profile. If successful, it uses that profile's
     * settings to activate the UI. Otherwise, it initiates a flow for the user to
     * select or create a new profile, keeping the main window hidden until a profile
     * is active. Commands generated are enqueued.
     */
    pub fn on_main_window_created(&mut self, window_id: WindowId) {
        self.main_window_id = Some(window_id);
        // Using UpdateStatusBarText for logging
        self.synchronous_command_queue
            .push_back(PlatformCommand::UpdateStatusBarText {
                window_id,
                text: format!(
                    "AppLogic: Main window created (ID: {:?}). Attempting to load last profile.",
                    window_id
                ),
                severity: MessageSeverity::Debug,
            });

        match self
            .config_manager
            .load_last_profile_name(APP_NAME_FOR_PROFILES)
        {
            Ok(Some(last_profile_name)) if !last_profile_name.is_empty() => {
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!(
                            "AppLogic: Found last used profile name: {}",
                            last_profile_name
                        ),
                        severity: MessageSeverity::Debug,
                    });
                match self
                    .profile_manager
                    .load_profile(&last_profile_name, APP_NAME_FOR_PROFILES)
                {
                    Ok(profile) => {
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: format!(
                                    "AppLogic: Successfully loaded last profile '{}' on startup.",
                                    profile.name
                                ),
                                severity: MessageSeverity::Information,
                            },
                        );
                        let operation_status_message =
                            format!("Profile '{}' loaded.", profile.name);
                        self._activate_profile_and_show_window(
                            window_id,
                            profile,
                            operation_status_message,
                        );
                    }
                    Err(e) => {
                        let err_msg = format!(
                            "Failed to load last profile '{}': {:?}. Initiating selection.",
                            last_profile_name, e
                        );
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: format!("AppLogic Error: {}", err_msg), // Prefix for clarity
                                severity: MessageSeverity::Error,
                            },
                        );
                        self.initiate_profile_selection_or_creation(window_id);
                    }
                }
            }
            Ok(_) => {
                self.synchronous_command_queue.push_back(PlatformCommand::UpdateStatusBarText {
                    window_id,
                    text: "AppLogic: No last profile name found or it was empty. Initiating selection/creation.".to_string(),
                    severity: MessageSeverity::Information,
                });
                self.initiate_profile_selection_or_creation(window_id);
            }
            Err(e) => {
                let err_msg = format!(
                    "Error loading last profile name: {:?}. Initiating selection.",
                    e
                );
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!("AppLogic Error: {}", err_msg),
                        severity: MessageSeverity::Error,
                    });
                self.initiate_profile_selection_or_creation(window_id);
            }
        }
    }

    fn gather_selected_deselected_paths_recursive(
        nodes: &[FileNode],
        selected: &mut HashSet<PathBuf>,
        deselected: &mut HashSet<PathBuf>,
    ) {
        for node in nodes {
            match node.state {
                FileState::Selected => {
                    selected.insert(node.path.clone());
                }
                FileState::Deselected => {
                    deselected.insert(node.path.clone());
                }
                FileState::Unknown => {}
            }
            if node.is_dir && !node.children.is_empty() {
                Self::gather_selected_deselected_paths_recursive(
                    &node.children,
                    selected,
                    deselected,
                );
            }
        }
    }

    fn create_profile_from_current_state(&self, new_profile_name: String) -> Profile {
        let mut selected_paths = HashSet::new();
        let mut deselected_paths = HashSet::new();

        Self::gather_selected_deselected_paths_recursive(
            &self.file_nodes_cache,
            &mut selected_paths,
            &mut deselected_paths,
        );

        Profile {
            name: new_profile_name,
            root_folder: self.root_path_for_scan.clone(),
            selected_paths,
            deselected_paths,
            archive_path: self
                .current_profile_cache
                .as_ref()
                .and_then(|p| p.archive_path.clone()),
        }
    }

    fn refresh_tree_view_from_cache(&mut self, window_id: WindowId) {
        self.next_tree_item_id_counter = 1;
        self.path_to_tree_item_id.clear();
        let descriptors = Self::build_tree_item_descriptors_recursive_internal(
            &self.file_nodes_cache,
            &mut self.path_to_tree_item_id,
            &mut self.next_tree_item_id_counter,
        );
        self.synchronous_command_queue
            .push_back(PlatformCommand::PopulateTreeView {
                window_id,
                items: descriptors,
            });
    }

    fn update_current_archive_status(&mut self) {
        if let Some(main_id) = self.main_window_id {
            // Ensure main_window_id is Some
            if let Some(profile) = &self.current_profile_cache {
                let status = self
                    .archiver
                    .check_archive_status(profile, &self.file_nodes_cache);
                self.current_archive_status = Some(status);

                let status_text = format!("Archive: {:?}", status);
                let severity = match status {
                    ArchiveStatus::ErrorChecking(_) => MessageSeverity::Error,
                    _ => MessageSeverity::Information,
                };
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id: main_id,
                        text: status_text,
                        severity,
                    });
            } else {
                self.current_archive_status = None;
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id: main_id,
                        text: "Archive: (No profile loaded)".to_string(),
                        severity: MessageSeverity::Information,
                    });
            }
        } else {
            // No main window, so can't update status bar, but can clear internal state
            self.current_archive_status = None;
            eprintln!(
                "AppLogic: update_current_archive_status called but no main_window_id. Status cleared internally."
            );
        }
    }

    pub(crate) fn find_filenode_mut<'a>(
        nodes: &'a mut [FileNode],
        path_to_find: &Path,
    ) -> Option<&'a mut FileNode> {
        for node in nodes.iter_mut() {
            if node.path == path_to_find {
                return Some(node);
            }
            if node.is_dir && !node.children.is_empty() {
                if let Some(found_in_child) =
                    Self::find_filenode_mut(&mut node.children, path_to_find)
                {
                    return Some(found_in_child);
                }
            }
        }
        None
    }

    pub(crate) fn find_filenode_ref<'a>(
        nodes: &'a [FileNode],
        path_to_find: &Path,
    ) -> Option<&'a FileNode> {
        for node in nodes.iter() {
            if node.path == path_to_find {
                return Some(node);
            }
            if node.is_dir && !node.children.is_empty() {
                if let Some(found_in_child) = Self::find_filenode_ref(&node.children, path_to_find)
                {
                    return Some(found_in_child);
                }
            }
        }
        None
    }

    pub(crate) fn collect_visual_updates_recursive(
        &self,
        node: &FileNode,
        updates: &mut Vec<(TreeItemId, CheckState)>,
    ) {
        if let Some(item_id) = self.path_to_tree_item_id.get(&node.path) {
            let check_state = match node.state {
                FileState::Selected => CheckState::Checked,
                _ => CheckState::Unchecked,
            };
            updates.push((*item_id, check_state));

            if node.is_dir {
                for child in &node.children {
                    self.collect_visual_updates_recursive(child, updates);
                }
            }
        } else {
            eprintln!(
                "AppLogic: Could not find TreeItemId for path {:?} during visual update collection.",
                node.path
            );
        }
    }

    fn handle_window_close_requested(&mut self, window_id: WindowId) {
        if self.main_window_id == Some(window_id) {
            println!("AppLogic: Main window close requested. Commanding platform to close.");
            self.synchronous_command_queue
                .push_back(PlatformCommand::CloseWindow { window_id });
        }
    }

    fn handle_window_destroyed(&mut self, window_id: WindowId) {
        if self.main_window_id == Some(window_id) {
            self.synchronous_command_queue
                .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id, // Use the ID of the window being destroyed for this log message
                    text: "AppLogic: Main window destroyed notification received.".to_string(),
                    severity: MessageSeverity::Debug,
                });
            self.main_window_id = None;
            // State related to current_profile_name, file_nodes_cache, current_profile_cache is kept for on_quit.
            self.current_archive_status = None; // This is window-specific transient state.
            self.path_to_tree_item_id.clear();
            self.pending_action = None;
            self.pending_new_profile_name = None;
        }
    }

    fn handle_treeview_item_toggled(
        &mut self,
        window_id: WindowId,
        item_id: TreeItemId,
        new_state: CheckState,
    ) {
        println!(
            "AppLogic: TreeItem {:?} in window {:?} toggled to UI state {:?}.",
            item_id, window_id, new_state
        );

        let mut path_of_toggled_node: Option<PathBuf> = None;
        for (path_candidate, id_in_map) in &self.path_to_tree_item_id {
            if *id_in_map == item_id {
                path_of_toggled_node = Some(path_candidate.clone());
                break;
            }
        }

        if let Some(path_for_model_update) = path_of_toggled_node {
            {
                let node_to_update_model_for =
                    Self::find_filenode_mut(&mut self.file_nodes_cache, &path_for_model_update);

                if let Some(node_model) = node_to_update_model_for {
                    let new_model_file_state = match new_state {
                        CheckState::Checked => FileState::Selected,
                        CheckState::Unchecked => FileState::Deselected,
                    };
                    self.state_manager
                        .update_folder_selection(node_model, new_model_file_state);
                } else {
                    eprintln!(
                        "AppLogic: Model node not found for path {:?} to update state.",
                        path_for_model_update
                    );
                }
            }

            if let Some(root_node_for_visual_update) =
                Self::find_filenode_ref(&self.file_nodes_cache, &path_for_model_update)
            {
                let mut visual_updates_list = Vec::new();
                self.collect_visual_updates_recursive(
                    root_node_for_visual_update,
                    &mut visual_updates_list,
                );
                println!(
                    "AppLogic: Requesting {} visual updates for TreeView after toggle.",
                    visual_updates_list.len()
                );
                for (id_to_update_ui, state_for_ui) in visual_updates_list {
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateTreeItemVisualState {
                            window_id,
                            item_id: id_to_update_ui,
                            new_state: state_for_ui,
                        },
                    );
                }
            } else {
                eprintln!(
                    "AppLogic: Model node not found for path {:?} to collect visual updates.",
                    path_for_model_update
                );
            }
            self.update_current_archive_status();
        } else {
            eprintln!(
                "AppLogic: Could not find path for TreeItemId {:?} from UI event.",
                item_id
            );
        }
    }

    fn handle_button_clicked(&mut self, window_id: WindowId, control_id: i32) {
        if self.main_window_id == Some(window_id) && control_id == ID_BUTTON_GENERATE_ARCHIVE_LOGIC
        {
            // This is now "Save to Archive"
            self.synchronous_command_queue
                .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id,
                    text: "AppLogic: 'Save to Archive' button clicked.".to_string(),
                    severity: MessageSeverity::Information,
                });

            if let Some(profile) = &self.current_profile_cache {
                if let Some(archive_path) = &profile.archive_path {
                    let display_root_path = profile.root_folder.clone();
                    match self
                        .archiver
                        .create_archive_content(&self.file_nodes_cache, &display_root_path)
                    {
                        Ok(content) => {
                            match self.archiver.save_archive_content(archive_path, &content) {
                                Ok(_) => {
                                    self.synchronous_command_queue.push_back(
                                        PlatformCommand::UpdateStatusBarText {
                                            window_id,
                                            text: format!(
                                                "Archive successfully saved to '{}'.",
                                                archive_path.display()
                                            ),
                                            severity: MessageSeverity::Information,
                                        },
                                    );
                                    self.update_current_archive_status();
                                }
                                Err(e) => {
                                    let err_msg = format!(
                                        "Failed to save archive content to '{}': {}",
                                        archive_path.display(),
                                        e
                                    );
                                    self.synchronous_command_queue.push_back(
                                        PlatformCommand::UpdateStatusBarText {
                                            window_id,
                                            text: err_msg,
                                            severity: MessageSeverity::Error,
                                        },
                                    );
                                }
                            }
                        }
                        Err(e) => {
                            let err_msg = format!("Failed to create archive content: {}", e);
                            self.synchronous_command_queue.push_back(
                                PlatformCommand::UpdateStatusBarText {
                                    window_id,
                                    text: err_msg,
                                    severity: MessageSeverity::Error,
                                },
                            );
                        }
                    }
                } else {
                    // This case should ideally not be reachable if button is disabled
                    self.synchronous_command_queue
                        .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text:
                            "Error: No archive path set for current profile. Cannot save archive."
                                .to_string(),
                        severity: MessageSeverity::Error,
                    });
                }
            } else {
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: "Error: No profile loaded. Cannot save archive.".to_string(),
                        severity: MessageSeverity::Error,
                    });
            }
        }
    }

    fn handle_menu_load_profile_clicked(&mut self) {
        println!("AppLogic: MenuLoadProfileClicked received.");
        if let Some(main_id) = self.main_window_id {
            let profile_dir_opt = self
                .profile_manager
                .get_profile_dir_path(APP_NAME_FOR_PROFILES);
            self.synchronous_command_queue
                .push_back(PlatformCommand::ShowOpenFileDialog {
                    window_id: main_id,
                    title: "Load Profile".to_string(),
                    filter_spec: "Profile Files (*.json)\0*.json\0\0".to_string(),
                    initial_dir: profile_dir_opt,
                });
        }
    }

    fn handle_file_open_dialog_completed(&mut self, window_id: WindowId, result: Option<PathBuf>) {
        if self.main_window_id == Some(window_id) {
            if let Some(profile_file_path) = result {
                println!(
                    "AppLogic: Profile selected for load: {:?}",
                    profile_file_path
                );
                match self
                    .profile_manager
                    .load_profile_from_path(&profile_file_path)
                {
                    Ok(loaded_profile) => {
                        let profile_name_clone = loaded_profile.name.clone();
                        println!(
                            "AppLogic: Successfully loaded profile '{}' via manager from path.",
                            loaded_profile.name
                        );
                        // Set current profile name before saving it as last used
                        self.current_profile_name = Some(loaded_profile.name.clone());
                        self.root_path_for_scan = loaded_profile.root_folder.clone();
                        if let Err(e) = self
                            .config_manager
                            .save_last_profile_name(APP_NAME_FOR_PROFILES, &loaded_profile.name)
                        {
                            // Log error, but don't prevent profile activation
                            eprintln!(
                                "AppLogic: Failed to save last profile name '{}': {:?}",
                                loaded_profile.name, e
                            );
                            // Optionally, inform user via status bar if this is critical enough
                            // self.synchronous_command_queue.push_back(PlatformCommand::UpdateStatusBarText {
                            //     window_id,
                            //     text: format!("Warning: Could not save '{}' as last used profile.", loaded_profile.name),
                            //     severity: MessageSeverity::Warning,
                            // });
                        }
                        let status_msg =
                            format!("Profile '{}' loaded and scanned.", profile_name_clone);
                        self._activate_profile_and_show_window(
                            window_id,
                            loaded_profile, // Pass the loaded profile
                            status_msg,
                        );
                    }
                    Err(e) => {
                        let err_msg = format!(
                            "Failed to load profile from {:?} via manager: {:?}",
                            profile_file_path, e
                        );
                        self.current_profile_name = None; // Clear current profile on load failure
                        self.current_profile_cache = None;
                        self.current_archive_status = None;
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: err_msg,
                                severity: MessageSeverity::Error,
                            },
                        );
                    }
                }
            } else {
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: "Load profile cancelled.".to_string(),
                        severity: MessageSeverity::Information,
                    });
            }
        }
    }

    fn handle_menu_save_profile_as_clicked(&mut self) {
        println!("AppLogic: MenuSaveProfileAsClicked received.");
        if let Some(main_id) = self.main_window_id {
            let profile_dir_opt = self
                .profile_manager
                .get_profile_dir_path(APP_NAME_FOR_PROFILES);
            let base_name = self
                .current_profile_name
                .as_ref()
                .map_or_else(|| "new_profile".to_string(), |name| name.clone());
            let sanitized_current_name = core::profiles::sanitize_profile_name(&base_name);
            let default_filename = format!("{}.json", sanitized_current_name);

            self.pending_action = Some(PendingAction::SavingProfile);
            self.synchronous_command_queue
                .push_back(PlatformCommand::ShowSaveFileDialog {
                    window_id: main_id,
                    title: "Save Profile As".to_string(),
                    default_filename,
                    filter_spec: "Profile Files (*.json)\0*.json\0\0".to_string(),
                    initial_dir: profile_dir_opt,
                });
        }
    }

    fn handle_file_save_dialog_completed(&mut self, window_id: WindowId, result: Option<PathBuf>) {
        let action = self.pending_action.take(); // Take the pending action first

        match action {
            Some(PendingAction::SettingArchivePath) => {
                // Handle new pending action
                if let Some(path) = result {
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: format!("AppLogic: Archive path selected: {:?}", path),
                            severity: MessageSeverity::Debug,
                        },
                    );
                    if let Some(profile) = &mut self.current_profile_cache {
                        profile.archive_path = Some(path.clone());
                        match self
                            .profile_manager
                            .save_profile(profile, APP_NAME_FOR_PROFILES)
                        {
                            Ok(_) => {
                                self.synchronous_command_queue.push_back(
                                    PlatformCommand::UpdateStatusBarText {
                                        window_id,
                                        text: format!(
                                            "Archive path set to '{}' for profile '{}' and saved.",
                                            path.display(),
                                            profile.name
                                        ),
                                        severity: MessageSeverity::Information,
                                    },
                                );
                                self._update_window_title_with_profile_and_archive(window_id);
                                self.update_current_archive_status();
                                self._update_save_to_archive_button_state(window_id);
                            }
                            Err(e) => {
                                let err_msg = format!(
                                    "Failed to save profile '{}' after setting archive path: {}",
                                    profile.name, e
                                );
                                self.synchronous_command_queue.push_back(
                                    PlatformCommand::UpdateStatusBarText {
                                        window_id,
                                        text: err_msg,
                                        severity: MessageSeverity::Error,
                                    },
                                );
                                // Revert archive_path in cache if save fails? Or leave it and let user retry save?
                                // For now, leave it as set in cache.
                            }
                        }
                    } else {
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: "Error: No profile active to set archive path for."
                                    .to_string(),
                                severity: MessageSeverity::Error,
                            },
                        );
                    }
                } else {
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: "Set archive path cancelled.".to_string(),
                            severity: MessageSeverity::Information,
                        },
                    );
                    // If cancelled, ensure button state is re-evaluated (it might have been disabled)
                    self._update_save_to_archive_button_state(window_id);
                }
            }
            Some(PendingAction::SavingArchive) => {
                // This case is now effectively obsolete due to direct save.
                // If it's somehow reached, it's an old path.
                // For robustness, clear any pending content and log a warning.
                // self.pending_archive_content = None; // Already removed
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id,
                    text:
                        "Warning: Obsolete 'SavingArchive' action handled. This should not happen."
                            .to_string(),
                    severity: MessageSeverity::Warning,
                });
                if result.is_none() {
                    // If dialog was cancelled from this old path
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: "Save archive (obsolete path) cancelled.".to_string(),
                            severity: MessageSeverity::Information,
                        },
                    );
                }
            }
            Some(PendingAction::SavingProfile) => {
                if let Some(profile_save_path) = result {
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: format!(
                                "AppLogic: Profile save path selected: {:?}",
                                profile_save_path
                            ),
                            severity: MessageSeverity::Debug,
                        },
                    );
                    if let Some(profile_name_osstr) = profile_save_path.file_stem() {
                        if let Some(profile_name_str) =
                            profile_name_osstr.to_str().map(|s| s.to_string())
                        {
                            if profile_name_str.trim().is_empty()
                                || !profile_name_str
                                    .chars()
                                    .all(core::profiles::is_valid_profile_name_char)
                            {
                                let err_msg = format!(
                                    "Invalid profile name extracted from path: '{}'. Profile not saved.",
                                    profile_name_str
                                );
                                self.synchronous_command_queue.push_back(
                                    PlatformCommand::UpdateStatusBarText {
                                        window_id,
                                        text: err_msg,
                                        severity: MessageSeverity::Error,
                                    },
                                );
                            } else {
                                let mut new_profile = self
                                    .create_profile_from_current_state(profile_name_str.clone());
                                // When saving "as", the new profile might or might not inherit the archive path.
                                // Let's assume it does NOT, to force user to "Set Archive Path" for the new profile.
                                // Or, for consistency, maybe it should inherit? Current create_profile_from_current_state DOES inherit.
                                // If we want it to not inherit, we'd do: new_profile.archive_path = None;
                                // For now, let's stick to current inheritance.

                                let profile_name_clone = new_profile.name.clone();
                                match self
                                    .profile_manager
                                    .save_profile(&new_profile, APP_NAME_FOR_PROFILES)
                                {
                                    Ok(()) => {
                                        self.synchronous_command_queue.push_back(PlatformCommand::UpdateStatusBarText {
                                            window_id,
                                            text: format!("AppLogic: Successfully saved profile as '{}' via manager.", new_profile.name),
                                            severity: MessageSeverity::Information,
                                        });
                                        self.current_profile_name = Some(new_profile.name.clone());
                                        self.current_profile_cache = Some(new_profile.clone());
                                        self.root_path_for_scan = self
                                            .current_profile_cache
                                            .as_ref()
                                            .unwrap()
                                            .root_folder
                                            .clone();

                                        self._update_window_title_with_profile_and_archive(
                                            window_id,
                                        ); // Update title

                                        if let Err(e) = self.config_manager.save_last_profile_name(
                                            APP_NAME_FOR_PROFILES,
                                            &new_profile.name,
                                        ) {
                                            self.synchronous_command_queue.push_back(PlatformCommand::UpdateStatusBarText {
                                                window_id,
                                                text: format!("AppLogic Warning: Failed to save last profile name '{}': {:?}", new_profile.name, e),
                                                severity: MessageSeverity::Warning,
                                            });
                                        }
                                        self.update_current_archive_status();
                                        self._update_save_to_archive_button_state(window_id); // Update button state
                                        // Status bar message for profile saved (distinct from archive status)
                                        self.synchronous_command_queue.push_back(
                                            PlatformCommand::UpdateStatusBarText {
                                                window_id,
                                                text: format!(
                                                    "Profile '{}' saved.",
                                                    profile_name_clone
                                                ),
                                                severity: MessageSeverity::Information,
                                            },
                                        );
                                    }
                                    Err(e) => {
                                        let err_msg = format!(
                                            "Failed to save profile (via manager) as '{}': {}",
                                            new_profile.name, e
                                        );
                                        self.synchronous_command_queue.push_back(
                                            PlatformCommand::UpdateStatusBarText {
                                                window_id,
                                                text: err_msg,
                                                severity: MessageSeverity::Error,
                                            },
                                        );
                                    }
                                }
                            }
                        } else {
                            let err_msg =
                                "Profile save filename stem not valid UTF-8. Profile not saved."
                                    .to_string();
                            self.synchronous_command_queue.push_back(
                                PlatformCommand::UpdateStatusBarText {
                                    window_id,
                                    text: err_msg,
                                    severity: MessageSeverity::Error,
                                },
                            );
                        }
                    } else {
                        let err_msg =
                            "Could not extract profile name from save path. Profile not saved."
                                .to_string();
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: err_msg,
                                severity: MessageSeverity::Error,
                            },
                        );
                    }
                } else {
                    // User cancelled Save Profile As
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: "Save profile cancelled.".to_string(),
                            severity: MessageSeverity::Information,
                        },
                    );
                }
            }
            // ... (other PendingAction cases)
            Some(PendingAction::CreatingNewProfileGetName)
            | Some(PendingAction::CreatingNewProfileGetRoot) => {
                let err_msg = format!(
                    "Unexpected FileSaveDialogCompleted with pending action: {:?}",
                    action
                );
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Error,
                    });
            }
            None => {
                let err_msg =
                    "FileSaveDialogCompleted received but no pending action was set.".to_string();
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Warning,
                    });
            }
        }
    }

    fn handle_window_resized(&mut self, _window_id: WindowId, _width: i32, _height: i32) {
        // Currently does not generate commands.
    }

    fn handle_menu_refresh_clicked(&mut self) {
        // New method for P2.9
        println!("AppLogic: MenuRefreshClicked received.");
        let window_id = match self.main_window_id {
            Some(id) => id,
            None => {
                eprintln!("AppLogic: Refresh requested but no main window ID set. Ignoring.");
                return;
            }
        };

        let current_profile_clone = match self.current_profile_cache.clone() {
            Some(profile) => profile,
            None => {
                println!("AppLogic: Refresh requested but no profile is active. Ignoring.");
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: "Refresh: No profile active.".to_string(),
                        severity: MessageSeverity::Warning,
                    });
                return;
            }
        };

        let root_path_to_scan = current_profile_clone.root_folder.clone();
        println!(
            "AppLogic: Refreshing file list for profile '{}', root: {:?}",
            current_profile_clone.name, root_path_to_scan
        );

        match self.file_system_scanner.scan_directory(&root_path_to_scan) {
            Ok(new_nodes) => {
                self.file_nodes_cache = new_nodes;
                println!(
                    "AppLogic: Scan successful, {} top-level nodes found.",
                    self.file_nodes_cache.len()
                );

                self.state_manager
                    .apply_profile_to_tree(&mut self.file_nodes_cache, &current_profile_clone);
                println!(
                    "AppLogic: Applied profile '{}' to refreshed tree.",
                    current_profile_clone.name
                );

                self.refresh_tree_view_from_cache(window_id);
                self.update_current_archive_status();

                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!(
                            "File list refreshed for profile '{}'.",
                            current_profile_clone.name
                        ),
                        severity: MessageSeverity::Information,
                    });
            }
            Err(e) => {
                let err_msg = format!("Failed to refresh file list: {}", e);
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Error,
                    });
            }
        }
    }

    /// Internal helper to finalize UI setup after a profile is active.
    fn _activate_profile_and_show_window(
        &mut self,
        window_id: WindowId,
        profile_to_activate: Profile,
        operation_status_message: String,
    ) {
        let mut status_message = operation_status_message;
        let mut status_severity = MessageSeverity::Information;

        self.current_profile_name = Some(profile_to_activate.name.clone());
        self.root_path_for_scan = profile_to_activate.root_folder.clone();
        self.current_profile_cache = Some(profile_to_activate.clone());

        self.synchronous_command_queue
            .push_back(PlatformCommand::UpdateStatusBarText {
                window_id,
                text: format!(
                    "AppLogic: Activating profile '{}'. Scanning directory: {:?}",
                    self.current_profile_name.as_ref().unwrap(),
                    self.root_path_for_scan
                ),
                severity: MessageSeverity::Debug,
            });

        self._update_window_title_with_profile_and_archive(window_id); // Set initial title

        match self
            .file_system_scanner
            .scan_directory(&self.root_path_for_scan)
        {
            Ok(nodes) => {
                self.file_nodes_cache = nodes;
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!(
                            "AppLogic: Scanned {} top-level nodes for active profile.",
                            self.file_nodes_cache.len()
                        ),
                        severity: MessageSeverity::Debug,
                    });

                self.state_manager
                    .apply_profile_to_tree(&mut self.file_nodes_cache, &profile_to_activate);
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!(
                            "AppLogic: Applied active profile '{}' to the scanned tree.",
                            profile_to_activate.name
                        ),
                        severity: MessageSeverity::Debug,
                    });
            }
            Err(e) => {
                let err_msg = format!(
                    "Failed to scan directory {:?} for profile '{}': {}",
                    self.root_path_for_scan, profile_to_activate.name, e
                );
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: format!("AppLogic Error: {}", err_msg),
                        severity: MessageSeverity::Error,
                    });
                self.file_nodes_cache.clear();
                status_message = err_msg; // Overwrite initial success message with scan error
                status_severity = MessageSeverity::Error;
            }
        }

        self.refresh_tree_view_from_cache(window_id);

        self.synchronous_command_queue
            .push_back(PlatformCommand::UpdateStatusBarText {
                window_id,
                text: status_message,
                severity: status_severity,
            });

        self.update_current_archive_status();
        self._update_save_to_archive_button_state(window_id); // Update button state

        self.synchronous_command_queue
            .push_back(PlatformCommand::ShowWindow { window_id });
    }

    /*
     * Initiates the UI flow for the user to select an existing profile or create a new one.
     * This is typically called at startup if no last-used profile can be loaded, or if
     * the user intends to switch profiles or is forced to after deleting an active profile.
     * It lists available profiles and commands the platform layer to display a
     * specialized dialog for this purpose. Commands are enqueued.
     */
    pub(crate) fn initiate_profile_selection_or_creation(&mut self, window_id: WindowId) {
        println!("AppLogic: Initiating profile selection or creation flow.");

        match self.profile_manager.list_profiles(APP_NAME_FOR_PROFILES) {
            Ok(available_profiles) => {
                let (title, prompt, emphasize_create_new) = if available_profiles.is_empty() {
                    (
                        "Welcome to SourcePacker!".to_string(),
                        "No profiles found. Please create a new profile to get started."
                            .to_string(),
                        true,
                    )
                } else {
                    (
                        "Select or Create Profile".to_string(),
                        "Please select an existing profile, or create a new one.".to_string(),
                        false,
                    )
                };

                println!(
                    "AppLogic: Found {} available profiles. Dialog prompt: '{}'",
                    available_profiles.len(),
                    prompt
                );

                self.synchronous_command_queue.push_back(
                    PlatformCommand::ShowProfileSelectionDialog {
                        window_id,
                        available_profiles,
                        title,
                        prompt,
                        emphasize_create_new,
                    },
                );
            }
            Err(e) => {
                let err_msg = format!(
                    "Failed to list profiles: {:?}. Cannot proceed with profile selection.",
                    e
                );
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Error,
                    });
            }
        }
    }

    fn handle_profile_selection_dialog_completed(
        &mut self,
        window_id: WindowId,
        chosen_profile_name: Option<String>,
        create_new_requested: bool,
        user_cancelled: bool,
    ) {
        println!(
            "AppLogic: ProfileSelectionDialogCompleted event received: window_id: {:?}, chosen: {:?}, create_new: {}, cancelled: {}",
            window_id, chosen_profile_name, create_new_requested, user_cancelled
        );

        if user_cancelled {
            println!("AppLogic: Profile selection was cancelled by user. Quitting application.");
            self.synchronous_command_queue
                .push_back(PlatformCommand::QuitApplication);
            return;
        }

        if create_new_requested {
            println!("AppLogic: User requested to create a new profile.");
            self.start_new_profile_creation_flow(window_id);
        } else if let Some(profile_name) = chosen_profile_name {
            println!(
                "AppLogic: User chose profile '{}'. Attempting to load.",
                profile_name
            );
            match self
                .profile_manager
                .load_profile(&profile_name, APP_NAME_FOR_PROFILES)
            {
                Ok(profile) => {
                    println!(
                        "AppLogic: Successfully loaded chosen profile '{}'.",
                        profile.name
                    );
                    let operation_status_message = format!("Profile '{}' loaded.", profile.name);
                    if let Err(e) = self
                        .config_manager
                        .save_last_profile_name(APP_NAME_FOR_PROFILES, &profile.name)
                    {
                        eprintln!(
                            "AppLogic: Failed to save last profile name '{}': {:?}",
                            profile.name, e
                        );
                    }
                    self._activate_profile_and_show_window(
                        window_id,
                        profile,
                        operation_status_message,
                    );
                }
                Err(e) => {
                    let err_msg = format!(
                        "Could not load profile '{}': {:?}. Please try again or create a new one.",
                        profile_name, e
                    );
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::UpdateStatusBarText {
                            window_id,
                            text: err_msg,
                            severity: MessageSeverity::Error,
                        },
                    );
                    self.initiate_profile_selection_or_creation(window_id);
                }
            }
        } else {
            let err_msg = "AppLogic: ProfileSelectionDialogCompleted in unexpected state (no choice, not create, not cancelled). Re-initiating.".to_string();
            eprintln!("{}", err_msg);
            self.synchronous_command_queue
                .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id,
                    text: err_msg,
                    severity: MessageSeverity::Warning, // Internal logic issue, but recoverable
                });
            self.initiate_profile_selection_or_creation(window_id);
        }
    }

    fn start_new_profile_creation_flow(&mut self, window_id: WindowId) {
        println!("AppLogic: Starting new profile creation flow (Step 1: Get Name).");
        self.pending_action = Some(PendingAction::CreatingNewProfileGetName);
        self.synchronous_command_queue
            .push_back(PlatformCommand::ShowInputDialog {
                window_id,
                title: "New Profile (1/2): Name".to_string(),
                prompt: "Enter a name for the new profile:".to_string(),
                default_text: None,
                context_tag: Some("NewProfileName".to_string()),
            });
    }

    fn handle_input_dialog_completed(
        &mut self,
        window_id: WindowId,
        text: Option<String>,
        context_tag: Option<String>,
    ) {
        println!(
            "AppLogic: InputDialogCompleted event received: window_id: {:?}, text: {:?}, context_tag: {:?}",
            window_id, text, context_tag
        );

        match context_tag.as_deref() {
            Some("NewProfileName") => {
                // self.pending_action should be CreatingNewProfileGetName here. We clear it after success or cancellation.
                if let Some(profile_name) = text {
                    if profile_name.trim().is_empty()
                        || !profile_name
                            .chars()
                            .all(core::profiles::is_valid_profile_name_char)
                    {
                        let err_msg = "Invalid profile name. Please use only letters, numbers, spaces, underscores, or hyphens.".to_string();
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: err_msg.clone(),
                                severity: MessageSeverity::Warning, // User input error, recoverable
                            },
                        );
                        // Re-issue ShowInputDialog for name, keeping pending_action
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::ShowInputDialog {
                                window_id,
                                title: "New Profile (1/2): Name".to_string(),
                                prompt:
                                    "Enter a name for the new profile (invalid previous attempt):"
                                        .to_string(),
                                default_text: Some(profile_name),
                                context_tag: Some("NewProfileName".to_string()),
                            },
                        );
                        return; // Keep pending_action as CreatingNewProfileGetName
                    }

                    println!(
                        "AppLogic: New profile name '{}' is valid. Proceeding to Step 2 (Get Root Folder).",
                        profile_name
                    );
                    self.pending_new_profile_name = Some(profile_name);
                    self.pending_action = Some(PendingAction::CreatingNewProfileGetRoot); // Transition action
                    self.synchronous_command_queue.push_back(
                        PlatformCommand::ShowFolderPickerDialog {
                            window_id,
                            title: "New Profile (2/2): Select Root Folder".to_string(),
                            initial_dir: None, // TODO: Consider a default, e.g., user's home or project dir
                        },
                    );
                } else {
                    // User cancelled the input dialog
                    println!(
                        "AppLogic: New profile name input cancelled by user. Returning to profile selection."
                    );
                    self.pending_action = None; // Clear action
                    self.pending_new_profile_name = None;
                    self.initiate_profile_selection_or_creation(window_id);
                }
            }
            _ => {
                let err_msg = format!(
                    "AppLogic: InputDialogCompleted with unhandled context: {:?}",
                    context_tag
                );
                eprintln!("{}", err_msg);
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Warning, // Unexpected context, but recoverable
                    });
                self.pending_action = None; // Clear any potentially mismatched pending action
            }
        }
    }

    fn handle_folder_picker_dialog_completed(
        &mut self,
        window_id: WindowId,
        path: Option<PathBuf>,
    ) {
        println!(
            "AppLogic: FolderPickerDialogCompleted event received: window_id: {:?}, path: {:?}",
            window_id, path
        );
        // self.pending_action should be CreatingNewProfileGetRoot. Clear it.
        self.pending_action = None;

        if let Some(root_folder_path) = path {
            if let Some(profile_name) = self.pending_new_profile_name.take() {
                // Take consumes the name
                println!(
                    "AppLogic: Creating new profile '{}' with root folder {:?}.",
                    profile_name, root_folder_path
                );
                let new_profile = Profile::new(profile_name.clone(), root_folder_path.clone());

                match self
                    .profile_manager
                    .save_profile(&new_profile, APP_NAME_FOR_PROFILES)
                {
                    Ok(_) => {
                        println!(
                            "AppLogic: Successfully saved new profile '{}'.",
                            new_profile.name
                        );
                        let operation_status_message =
                            format!("New profile '{}' created and loaded.", new_profile.name);

                        if let Err(e) = self
                            .config_manager
                            .save_last_profile_name(APP_NAME_FOR_PROFILES, &new_profile.name)
                        {
                            eprintln!(
                                "AppLogic: Failed to save last profile name '{}': {:?}",
                                new_profile.name, e
                            );
                        }
                        self._activate_profile_and_show_window(
                            window_id,
                            new_profile,
                            operation_status_message,
                        );
                    }
                    Err(e) => {
                        let err_msg = format!(
                            "Failed to save new profile '{}': {:?}. Please try again.",
                            profile_name, e
                        );
                        self.synchronous_command_queue.push_back(
                            PlatformCommand::UpdateStatusBarText {
                                window_id,
                                text: err_msg,
                                severity: MessageSeverity::Error,
                            },
                        );
                        self.initiate_profile_selection_or_creation(window_id);
                    }
                }
            } else {
                let err_msg = "AppLogic: FolderPickerDialogCompleted but no pending profile name. Re-initiating profile selection.".to_string();
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id,
                        text: err_msg,
                        severity: MessageSeverity::Warning, // Internal state issue
                    });
                self.initiate_profile_selection_or_creation(window_id);
            }
        } else {
            println!(
                "AppLogic: Root folder selection cancelled by user. Returning to profile selection."
            );
            self.pending_new_profile_name = None; // Clear any pending name
            self.initiate_profile_selection_or_creation(window_id);
        }
    }

    /// Helper to format and set the main window title based on current profile and archive path.
    fn _update_window_title_with_profile_and_archive(&mut self, window_id: WindowId) {
        let mut title = "SourcePacker".to_string();
        if let Some(profile) = &self.current_profile_cache {
            title = format!("{} - [{}]", title, profile.name);
            if let Some(archive_path) = &profile.archive_path {
                title = format!("{} - [{}]", title, archive_path.display());
            } else {
                title = format!("{} - [No Archive Set]", title);
            }
        }
        self.synchronous_command_queue
            .push_back(PlatformCommand::SetWindowTitle { window_id, title });
    }

    /// Helper to enable/disable the "Save to Archive" button.
    fn _update_save_to_archive_button_state(&mut self, window_id: WindowId) {
        let enabled = self
            .current_profile_cache
            .as_ref()
            .and_then(|p| p.archive_path.as_ref())
            .is_some();

        self.synchronous_command_queue
            .push_back(PlatformCommand::SetControlEnabled {
                window_id,
                control_id: ID_BUTTON_GENERATE_ARCHIVE_LOGIC, // This is the "Save to Archive" button
                enabled,
            });
        if !enabled {
            self.synchronous_command_queue
                .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id,
                    text: "Button 'Save to Archive' disabled: No archive path set in profile."
                        .to_string(),
                    severity: MessageSeverity::Information,
                });
        }
    }

    fn handle_menu_set_archive_clicked(&mut self) {
        if let Some(main_id) = self.main_window_id {
            self.synchronous_command_queue
                .push_back(PlatformCommand::UpdateStatusBarText {
                    window_id: main_id,
                    text: "AppLogic: MenuSetArchiveClicked received.".to_string(),
                    severity: MessageSeverity::Debug,
                });
            if self.current_profile_cache.is_some() {
                self.pending_action = Some(PendingAction::SettingArchivePath);

                let default_filename = self
                    .current_profile_cache
                    .as_ref()
                    .and_then(|p| p.archive_path.as_ref().and_then(|ap| ap.file_name()))
                    .map(|os_name| os_name.to_string_lossy().into_owned())
                    .unwrap_or_else(|| {
                        self.current_profile_cache
                            .as_ref()
                            .map(|p| core::profiles::sanitize_profile_name(&p.name) + ".txt")
                            .unwrap_or_else(|| "archive.txt".to_string())
                    });

                let initial_dir_for_dialog = self
                    .current_profile_cache
                    .as_ref()
                    .and_then(|p| {
                        p.archive_path
                            .as_ref()
                            .and_then(|ap| ap.parent().map(PathBuf::from))
                    })
                    .or_else(|| {
                        self.current_profile_cache
                            .as_ref()
                            .map(|p| p.root_folder.clone())
                    });

                self.synchronous_command_queue
                    .push_back(PlatformCommand::ShowSaveFileDialog {
                        window_id: main_id,
                        title: "Set Archive File Path".to_string(),
                        default_filename,
                        filter_spec: "Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0\0"
                            .to_string(),
                        initial_dir: initial_dir_for_dialog,
                    });
            } else {
                self.synchronous_command_queue
                    .push_back(PlatformCommand::UpdateStatusBarText {
                        window_id: main_id,
                        text: "Cannot set archive path: No profile is active.".to_string(),
                        severity: MessageSeverity::Warning,
                    });
            }
        }
    }
}

impl PlatformEventHandler for MyAppLogic {
    fn try_dequeue_command(&mut self) -> Option<PlatformCommand> {
        self.synchronous_command_queue.pop_front()
    }

    fn handle_event(&mut self, event: AppEvent) {
        // It's good practice to clear transient pending states if an unrelated event comes in,
        // or ensure dialog completion events correctly clear their specific pending states.
        // For now, specific handlers manage their pending states.

        match event {
            AppEvent::WindowCloseRequestedByUser { window_id } => {
                self.handle_window_close_requested(window_id);
            }
            AppEvent::WindowDestroyed { window_id } => {
                self.handle_window_destroyed(window_id);
            }
            AppEvent::TreeViewItemToggledByUser {
                window_id,
                item_id,
                new_state,
            } => {
                self.handle_treeview_item_toggled(window_id, item_id, new_state);
            }
            AppEvent::ButtonClicked {
                window_id,
                control_id,
            } => {
                self.handle_button_clicked(window_id, control_id);
            }
            AppEvent::MenuLoadProfileClicked => {
                self.handle_menu_load_profile_clicked();
            }
            AppEvent::FileOpenProfileDialogCompleted { window_id, result } => {
                self.handle_file_open_dialog_completed(window_id, result);
            }
            AppEvent::MenuSaveProfileAsClicked => {
                self.handle_menu_save_profile_as_clicked();
            }
            AppEvent::MenuSetArchiveClicked => {
                self.handle_menu_set_archive_clicked();
            }
            AppEvent::FileSaveDialogCompleted { window_id, result } => {
                self.handle_file_save_dialog_completed(window_id, result);
            }
            AppEvent::MenuRefreshClicked => {
                self.handle_menu_refresh_clicked();
            }
            AppEvent::WindowResized {
                window_id,
                width,
                height,
            } => {
                self.handle_window_resized(window_id, width, height);
            }
            AppEvent::ProfileSelectionDialogCompleted {
                window_id,
                chosen_profile_name,
                create_new_requested,
                user_cancelled,
            } => {
                self.handle_profile_selection_dialog_completed(
                    window_id,
                    chosen_profile_name,
                    create_new_requested,
                    user_cancelled,
                );
            }
            AppEvent::GenericInputDialogCompleted {
                window_id,
                text,
                context_tag,
            } => {
                self.handle_input_dialog_completed(window_id, text, context_tag);
            }
            AppEvent::FolderPickerDialogCompleted { window_id, path } => {
                self.handle_folder_picker_dialog_completed(window_id, path);
            }
        }
    }

    /*
     * Called by the platform layer when the application is about to exit its main loop.
     * This method handles saving the current state of the active profile (if any) to disk,
     * ensuring that selections and other profile-specific data are persisted.
     * It also saves the name of this last active profile to the application's configuration,
     * so it can be reloaded on the next startup.
     */
    fn on_quit(&mut self) {
        // Using eprintln directly here as status bar might not be available or processed.
        eprintln!("AppLogic: on_quit called by platform. Application is exiting.");

        // Save the content of the currently active profile, if any
        if let Some(active_profile_name) = self.current_profile_name.clone() {
            if !active_profile_name.is_empty() {
                let profile_to_save =
                    self.create_profile_from_current_state(active_profile_name.clone());
                eprintln!(
                    "AppLogic: Attempting to save content of active profile '{}' on exit.",
                    active_profile_name
                );
                match self
                    .profile_manager
                    .save_profile(&profile_to_save, APP_NAME_FOR_PROFILES)
                {
                    Ok(_) => eprintln!(
                        "AppLogic: Successfully saved content of profile '{}' to disk on exit.",
                        active_profile_name
                    ),
                    Err(e) => eprintln!(
                        "AppLogic: Error saving content of profile '{}' on exit: {:?}",
                        active_profile_name, e
                    ),
                }
            }
        }

        let profile_name_to_save_in_config = self.current_profile_name.as_deref().unwrap_or("");
        eprintln!(
            "AppLogic: Attempting to save last profile name '{}' to config on exit.",
            profile_name_to_save_in_config
        );
        match self
            .config_manager
            .save_last_profile_name(APP_NAME_FOR_PROFILES, profile_name_to_save_in_config)
        {
            Ok(_) => {
                if profile_name_to_save_in_config.is_empty() {
                    eprintln!(
                        "AppLogic: Successfully cleared/unset last profile name in config on exit."
                    );
                } else {
                    eprintln!(
                        "AppLogic: Successfully saved last active profile name '{}' to config on exit.",
                        profile_name_to_save_in_config
                    );
                }
            }
            Err(e) => eprintln!(
                "AppLogic: Error saving last profile name to config on exit: {:?}",
                e
            ),
        }
    }

    fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }
}

#[cfg(test)]
impl MyAppLogic {
    pub(crate) fn test_main_window_id(&self) -> Option<WindowId> {
        self.main_window_id
    }
    pub(crate) fn test_set_main_window_id(&mut self, v: Option<WindowId>) {
        self.main_window_id = v;
    }

    pub(crate) fn test_file_nodes_cache(&mut self) -> &mut Vec<FileNode> {
        &mut self.file_nodes_cache
    }
    pub(crate) fn test_set_file_nodes_cache(&mut self, v: Vec<FileNode>) {
        self.file_nodes_cache = v;
    }
    pub(crate) fn test_find_filenode_mut(&mut self, path_to_find: &Path) -> Option<&mut FileNode> {
        return Self::find_filenode_mut(&mut self.file_nodes_cache, path_to_find);
    }

    pub(crate) fn test_path_to_tree_item_id(&self) -> &PathToTreeItemIdMap {
        &self.path_to_tree_item_id
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_path_to_tree_item_id(&mut self, v: PathToTreeItemIdMap) {
        self.path_to_tree_item_id = v;
    }
    pub(crate) fn test_path_to_tree_item_id_clear(&mut self) {
        self.next_tree_item_id_counter = 1;
        self.path_to_tree_item_id.clear();
    }
    pub(crate) fn test_path_to_tree_item_id_insert(&mut self, path: &PathBuf, id: TreeItemId) {
        self.path_to_tree_item_id.insert(path.to_path_buf(), id);
    }
    #[allow(dead_code)]
    pub(crate) fn test_next_tree_item_id_counter(&self) -> u64 {
        self.next_tree_item_id_counter
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_next_tree_item_id_counter(&mut self, v: u64) {
        self.next_tree_item_id_counter = v;
    }

    pub(crate) fn test_root_path_for_scan(&self) -> &PathBuf {
        &self.root_path_for_scan
    }
    pub(crate) fn test_set_root_path_for_scan(&mut self, v: PathBuf) {
        self.root_path_for_scan = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_root_path_for_scan_set(&mut self, v: &Path) {
        // Added for convenience
        self.root_path_for_scan = v.to_path_buf();
    }

    pub(crate) fn test_current_profile_name(&self) -> &Option<String> {
        &self.current_profile_name
    }
    pub(crate) fn test_set_current_profile_name(&mut self, v: Option<String>) {
        self.current_profile_name = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_current_set(
        // Added for convenience
        &mut self,
        name: Option<String>,
        cache: Option<Profile>,
        status: Option<ArchiveStatus>,
    ) {
        self.current_profile_name = name;
        self.current_profile_cache = cache;
        self.current_archive_status = status;
    }

    pub(crate) fn test_current_profile_cache(&self) -> &Option<Profile> {
        &self.current_profile_cache
    }
    pub(crate) fn test_set_current_profile_cache(&mut self, v: Option<Profile>) {
        self.current_profile_cache = v;
    }

    pub(crate) fn test_current_archive_status(&self) -> &Option<ArchiveStatus> {
        &self.current_archive_status
    }
    pub(crate) fn test_set_current_archive_status(&mut self, v: Option<ArchiveStatus>) {
        self.current_archive_status = v;
    }

    pub(crate) fn test_pending_action(&self) -> &Option<PendingAction> {
        &self.pending_action
    }
    pub(crate) fn test_set_pending_action(&mut self, v: PendingAction) {
        self.pending_action = Some(v);
    }

    pub(crate) fn test_pending_new_profile_name(&self) -> &Option<String> {
        &self.pending_new_profile_name
    }
    pub(crate) fn test_set_pending_new_profile_name(&mut self, v: Option<String>) {
        self.pending_new_profile_name = v;
    }

    #[allow(dead_code)]
    pub(crate) fn test_config_manager(&self) -> &Arc<dyn ConfigManagerOperations> {
        &self.config_manager
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_config_manager(&mut self, v: Arc<dyn ConfigManagerOperations>) {
        self.config_manager = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_profile_manager(&self) -> &Arc<dyn ProfileManagerOperations> {
        &self.profile_manager
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_profile_manager(&mut self, v: Arc<dyn ProfileManagerOperations>) {
        self.profile_manager = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_file_system_scanner(&self) -> &Arc<dyn FileSystemScannerOperations> {
        &self.file_system_scanner
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_file_system_scanner(&mut self, v: Arc<dyn FileSystemScannerOperations>) {
        self.file_system_scanner = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_archiver(&self) -> &Arc<dyn ArchiverOperations> {
        &self.archiver
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_archiver(&mut self, v: Arc<dyn ArchiverOperations>) {
        self.archiver = v;
    }
    #[allow(dead_code)]
    pub(crate) fn test_state_manager(&self) -> &Arc<dyn StateManagerOperations> {
        &self.state_manager
    }
    #[allow(dead_code)]
    pub(crate) fn test_set_state_manager(&mut self, v: Arc<dyn StateManagerOperations>) {
        self.state_manager = v;
    }

    pub(crate) fn test_drain_commands(&mut self) -> Vec<PlatformCommand> {
        self.synchronous_command_queue.drain(..).collect()
    }
}
