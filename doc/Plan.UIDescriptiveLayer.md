# Refactoring Plan: UI Construction via `ui_description_layer`

This plan outlines the steps to refactor SourcePacker so that the main UI structure is defined by a new `ui_description_layer` which generates `PlatformCommand`s. The `platform_layer` will then execute these commands to create UI elements, rather than creating them implicitly (e.g., in `WM_CREATE`).

**Goal:** Decouple UI structure definition from the platform-specific implementation, improve testability, and pave the way for a more reusable `platform_layer`. The application should remain functional after each major step. We want the platform_layer to be independent of the actual application UI. The goal is to eventually break it out into a separate library that any application can use.

Whenever you want to change how your window looks like or population of controls, you should never need to change the platform_layer.

---

## Phase A: MVP Refinements, Platform Layer Restructuring, and Generic Layout

**Goal:** Further refine the separation of concerns according to MVP principles, making the `platform_layer` a truly generic View. This involves:
1.  Ensuring all UI-specific knowledge (including layout definitions and application-specific control IDs) resides in the `ui_description_layer` (View definition) or `app_logic` (Presenter).
2.  Enhancing the `platform_layer`'s layout engine to support dynamic and proportional sizing driven by generic `LayoutRule`s.
3.  Generalizing `platform_layer` commands for controls (like TreeView) to be targetable by logical `control_id`s.
4.  Restructuring `platform_layer` code for better maintainability (e.g., by migrating control-specific logic to dedicated handlers).
The `ui_description_layer` must fully define the UI structure and layout via `PlatformCommand`s, and `platform_layer` must become UI-agnostic, processing these commands generically.

**Sub-Phase A.I: Initial Command-Driven UI Creation**
    *   **(Completed)** UI elements like MainMenu, TreeView, Panels, and Labels are created via `PlatformCommand`s generated by `ui_description_layer`.

**Sub-Phase A.II: Implementing Generic Layout, Controls, and Handlers**

**Step A.II.1: Aggressively Implement a Truly Generic Layout Engine (Strengthens Original A.II.1)**
    *   **(Completed)**

**Step A.II.2: Generic Control Creation (e.g., Static Text/Labels)**
    *   **(Mostly Completed)** `PlatformCommand::CreateLabel` and `PlatformCommand::CreatePanel` are used. Layout of labels *within* the status panel needs to be driven by their own generic `LayoutRule`s (addressed in A.II.1).

**Step A.II.3: Generic Control Update Mechanism (e.g., UpdateLabelText)**
    *   **(Completed)** `PlatformCommand::UpdateLabelText` is used by `MyAppLogic` and `WM_CTLCOLORSTATIC` in `window_common.rs` correctly uses `label_severities`.

**Step A.II.4: Ensure All Control Operations Are Generically Targetable (Strengthens Original A.II.4)**
    *   Completed

**Step A.II.6: Create `controls` Sub-Module and Handler Skeletons (Renumbered from A.II.5)**
    *   **Action a:** Create `src/platform_layer/controls/` directory and `mod.rs`.
    *   **Action b:** Create empty or skeleton `menu_handler.rs`, `button_handler.rs`, `label_handler.rs`, `panel_handler.rs` etc., in the new `controls` module.
    *   **Action c:** Rename `platform_layer/control_treeview.rs` to `src/platform_layer/controls/treeview_handler.rs` and update all `use` statements and module references.
    *   *Verification:* Compiles. App runs as before. Project structure for control handlers is in place.

**Step A.II.7: Migrate Control-Specific Logic to Handlers (Iteratively) (Renumbered from A.II.6)**
    *   **For each control type (e.g., Label, TreeView, Menu, Button, Panel):**
        *   **Action a (Command Handling):**
            1.  Identify the function in `platform_layer::command_executor.rs` that handles its creation and updates (e.g., `execute_create_label`, `execute_update_label_text`).
            2.  Move this function's implementation into the appropriate `*_handler.rs` (e.g., `label_handler::handle_create_label_command`, `label_handler::handle_update_label_text_command`).
            3.  Update `platform_layer::command_executor::_execute_platform_command` to call the new handler function.
            *   *Verification:* Compiles. The specific control is still created and updated correctly. App functional.
        *   **Action b (Notification/Message Handling):**
            1.  Identify the parts of `platform_layer::window_common::Win32ApiInternalState::handle_window_message` (e.g., `WM_CTLCOLORSTATIC` for labels, `WM_NOTIFY` for TreeView, `WM_COMMAND` for menus/buttons) that deal with this specific control's events or drawing.
            2.  Move this logic into a new function within the control's `*_handler.rs` (e.g., `label_handler::handle_wm_ctlcolorstatic(...)`, `treeview_handler::handle_wm_notify(...)`). This function will take necessary parameters (like `Arc<Win32ApiInternalState>`, `HWND` of control, message params, `WindowId`).
            3.  Modify the relevant message handlers in `window_common.rs` to call this new handler function from the control's module.
            *   *Verification:* Compiles. Events/drawing for that specific control are still processed correctly by its dedicated handler. `window_common.rs` becomes more of a router. App functional.
    *   **Priority Order for Migration:**
        1.  Label (`label_handler.rs`)
        2.  TreeView (`treeview_handler.rs`)
        3.  Menu (`menu_handler.rs`)
        4.  Panel (`panel_handler.rs`)
        5.  Button (`button_handler.rs`) (if any generic buttons are added later)

---

**Sub-Phase A.III: Review and Finalize Platform Layer Generality**

**Step A.III.1: Review and Remove Residual UI-Specific Knowledge (Original A.III.1, formerly A.5)**
    *   **Action:** After all control logic is migrated and generic layout/targeting is fully implemented, perform a thorough review of `platform_layer` (especially `window_common.rs`, `command_executor.rs`, and the new `controls` handlers) to ensure no SourcePacker-specific UI logic, layout assumptions, or control ID knowledge remains. All such specifics should be driven by `PlatformCommand`s generated by `ui_description_layer` or decisions made in `app_logic`.
    *   Ensure constants like `ID_TREEVIEW_CTRL` are only used in `app_logic::ui_constants` and passed into `platform_layer` via commands, not hardcoded within `platform_layer` for operational logic.
    *   *Verification:* Code review confirms increased generality. `platform_layer` acts as a generic command executor and event translator. App functional.

**Step A.III.2: Future Exploration: Advanced Layout and Deeper Decomposition (Original A.III.2, formerly A.6)**
    *   **(Future)** This remains a longer-term goal. Consider advanced layout managers (e.g., grid, stack panels) as generic offerings within `platform_layer`, configurable by `ui_description_layer` via `PlatformCommand`s.
    *   **(Future)** Evaluate if `NativeWindowData` itself can be made more generic or if control-specific state can be fully encapsulated within their respective handlers (e.g., `TreeViewInternalState` map mentioned in A.II.4).

