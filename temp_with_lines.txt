   1 /*
   2  * This module defines the ProfileRuntimeData struct and the ProfileRuntimeDataOperations trait.
   3  * ProfileRuntimeData holds the core, mutable data for an active application session,
   4  * such as current profile details, scanned file nodes, and token caches.
   5  * The ProfileRuntimeDataOperations trait provides an abstraction for interacting with
   6  * this session data, facilitating dependency injection and testing.
   7  */
   9     FileNode, FileSystemScannerOperations, NodeStateApplicatorOperations, Profile, SelectionState,
  10     TokenCounterOperations,
  11     file_node::FileTokenDetails,
  14 use rayon::prelude::*;
  18     fs,
  21     thread,
  24 
  25 /*
  26  * Defines the operations for managing the runtime data of an active profile session.
  27  * This trait abstracts access and manipulation of session-specific information like
  28  * profile identifiers, file system snapshots, selection states, and token counts.
  29  * It is designed to be implemented by `ProfileRuntimeData` and mocked for testing.
  30  */
  32     // Profile identification
  33     fn get_profile_name(&self) -> Option<String>;
  34     fn set_profile_name(&mut self, name: Option<String>);
  35 
  36     // Archive path
  37     fn get_archive_path(&self) -> Option<PathBuf>;
  38     fn set_archive_path(&mut self, path: Option<PathBuf>);
  39 
  40     // Root scan path
  41     fn get_root_path_for_scan(&self) -> PathBuf;
  42     fn get_exclude_patterns(&self) -> Vec<String>;
  43     fn set_exclude_patterns(&mut self, patterns: Vec<String>);
  44 
  45     // File system snapshot (nodes)
  46     fn get_snapshot_nodes(&self) -> &Vec<FileNode>;
  47     fn set_snapshot_nodes(&mut self, nodes: Vec<FileNode>);
  48     fn apply_selection_states_to_snapshot(
  49         &mut self,
  50         state_manager: &dyn NodeStateApplicatorOperations,
  51         selected_paths: &HashSet<PathBuf>,
  52         deselected_paths: &HashSet<PathBuf>,
  53     );
  54     fn get_node_attributes_for_path(&self, path: &Path) -> Option<(SelectionState, bool)>; // (state, is_dir)
  55     fn update_node_state_and_collect_changes(
  56         &mut self,
  57         path: &Path,
  58         new_state: SelectionState,
  59         state_manager: &dyn NodeStateApplicatorOperations,
  60     ) -> Vec<(PathBuf, SelectionState)>;
  61     /*
  62      * Checks if the file or folder at the given path, or any of its descendants
  63      * (if it's a folder), contains any file in the 'New' state.
  64      */
  65     fn does_path_or_descendants_contain_new_file(&self, path: &Path) -> bool;
  66 
  67     // Token related data
  68     #[allow(dead_code)]
  69     fn update_total_token_count_for_selected_files(
  70         &mut self,
  71         token_counter: &dyn TokenCounterOperations,
  72     ) -> usize;
  73 
  74     fn recalc_tokens_async(
  75         &mut self,
  76         token_counter: Arc<dyn TokenCounterOperations>,
  77         only_selected: bool,
  78     ) -> Option<TokenProgressChannel>;
  79 
  80     fn apply_token_progress(&mut self, progress: TokenProgress) -> usize;
  81 
  82     // General session management
  83     fn clear(&mut self);
  84     fn create_profile_snapshot(&self) -> Profile;
  85     fn load_profile_into_session(
  86         &mut self,
  87         loaded_profile: Profile,
  88         file_system_scanner: &dyn FileSystemScannerOperations,
  89         state_manager: &dyn NodeStateApplicatorOperations,
  90         token_counter: &dyn TokenCounterOperations,
  91     ) -> Result<(), String>; // String is error message
  92     fn get_current_selection_paths(&self) -> (HashSet<PathBuf>, HashSet<PathBuf>);
  94 
  95 /*
  96  * Holds the core data for an active application session.
  97  * This includes information about the current profile being worked on (name, root folder,
  98  * archive path), the cache of scanned file nodes, the root path for file system scans,
  99  * the estimated token count for selected files, and a cache of token details for individual files.
 100  */
 102     profile_name: Option<String>,
 103     archive_path: Option<PathBuf>,
 104     file_system_snapshot_nodes: Vec<FileNode>,
 105     root_path_for_scan: PathBuf,
 106     cached_token_count: usize,
 107     cached_file_token_details: HashMap<PathBuf, FileTokenDetails>,
 108     exclude_patterns: Vec<String>,
 110 
 111 /*
 112  * Bundles the pieces required by the UI layer to monitor asynchronous token recalculation.
 113  * The `receiver` delivers progress batches, while the optional `worker_handle` can be joined
 114  * once completion is observed to ensure orderly thread cleanup.
 115  */
 117     pub receiver: mpsc::Receiver<TokenProgress>,
 118     pub worker_handle: Option<thread::JoinHandle<()>>,
 119     pub total_files: usize,
 121 
 122 const TOKEN_BATCH_SIZE: usize = 64;
 123 const PROGRESS_THROTTLE: Duration = Duration::from_millis(200);
 124 
 125 /*
 126  * Represents the immutable facts needed by the worker to decide whether to reuse cached
 127  * token counts or recompute them for a specific file. Populated on the main thread and
 128  * moved wholesale into the background task.
 129  */
 131     path: PathBuf,
 132     checksum: String,
 133     is_selected: bool,
 134     cached: Option<FileTokenDetails>,
 136 
 137 fn process_work_item(
 138     item: &TokenWorkItem,
 139     token_counter: &Arc<dyn TokenCounterOperations>,
 141     let mut invalidate_cache = false;
 142     let mut details_to_store = None;
 145             Some(cached.token_count)
 147             None
 150 
 154                 let counted = token_counter.count_tokens(&content);
 155                 token_count_opt = Some(counted);
 157                     checksum: item.checksum.clone(),
 158                     token_count: counted,
 162                 log::warn!(
 164                     item.path
 165                 );
 166                 invalidate_cache = true;
 167                 token_count_opt = Some(0);
 171 
 173         path: item.path.clone(),
 174         token_count: token_count_opt.unwrap_or(0),
 175         is_selected: item.is_selected,
 176         details: details_to_store,
 177         invalidate_cache,
 180 
 182     /*
 183      * Creates a new `ProfileRuntimeData` instance with default values.
 184      * Initializes with no profile loaded, an empty file cache, a default
 185      * root scan path (current directory), zero tokens, and an empty token details cache.
 186      */
 188         log::debug!("ProfileRuntimeData::new called - initializing default session data.");
 190             profile_name: None,
 191             archive_path: None,
 192             file_system_snapshot_nodes: Vec::new(),
 193             root_path_for_scan: PathBuf::from("."), // Default to current directory
 194             cached_token_count: 0,
 195             cached_file_token_details: HashMap::new(),
 196             exclude_patterns: Vec::new(),
 199 
 200     /*
 201      * Try the cache first. If not found or stale, read the file, count tokens, and update the cache.
 202      * Asserts that node.checksum is Some, as this function is only valid in that context.
 203      * Returns None if the file cannot be read.
 204      */
 205     fn get_token_count_with_cache(
 206         token_counter_service: &dyn TokenCounterOperations,
 207         node: &FileNode,
 208         cache: &mut HashMap<PathBuf, FileTokenDetails>,
 212                 return Some(details.token_count);
 215 
 217             Ok(c) => c,
 219                 // Remove any stale checksum from the cache
 220                 cache.remove(node.path());
 221                 return None;
 224 
 225         let tokens_in_file = token_counter_service.count_tokens(&content);
 226 
 227         cache.insert(
 228             node.path().to_path_buf(),
 229             node.new_file_token_details(tokens_in_file),
 230         );
 231 
 232         Some(tokens_in_file)
 234 
 235     // Helper: Recursively finds a reference to a FileNode within a slice of nodes.
 236     fn find_node_recursive_ref<'a>(
 237         nodes: &'a [FileNode],
 238         path_to_find: &Path,
 242                 return Some(node);
 245                 if let Some(found_in_child) =
 246                     Self::find_node_recursive_ref(&node.children, path_to_find)
 248                     return Some(found_in_child);
 252         None
 254 
 255     // Helper: Recursively finds a mutable reference to a FileNode within a slice of nodes.
 256     fn find_node_recursive_mut<'a>(
 257         nodes: &'a mut [FileNode],
 258         path_to_find: &Path,
 262                 return Some(node);
 265                 if let Some(found_in_child) =
 266                     Self::find_node_recursive_mut(&mut node.children, path_to_find)
 268                     return Some(found_in_child);
 272         None
 274 
 275     // Helper: Gathers selected and deselected paths from a node tree.
 276     fn gather_selected_deselected_paths_recursive_internal(
 277         nodes: &[FileNode],
 278         selected: &mut HashSet<PathBuf>,
 279         deselected: &mut HashSet<PathBuf>,
 284                     selected.insert(node.path().to_path_buf());
 287                     deselected.insert(node.path().to_path_buf());
 292                 Self::gather_selected_deselected_paths_recursive_internal(
 293                     &node.children,
 294                     selected,
 295                     deselected,
 296                 );
 300 
 302         let mut items = Vec::new();
 303         Self::collect_token_work_items_recursive(
 304             &self.file_system_snapshot_nodes,
 305             only_selected,
 306             &self.cached_file_token_details,
 307             &mut items,
 308         );
 309         items
 311 
 312     fn collect_token_work_items_recursive(
 313         nodes: &[FileNode],
 314         only_selected: bool,
 315         cache: &HashMap<PathBuf, FileTokenDetails>,
 316         acc: &mut Vec<TokenWorkItem>,
 320                 Self::collect_token_work_items_recursive(&node.children, only_selected, cache, acc);
 321                 continue;
 323 
 324             let is_selected = node.state() == SelectionState::Selected;
 326                 continue;
 328 
 330                 path: node.path().to_path_buf(),
 331                 checksum: node.checksum().to_string(),
 332                 is_selected,
 333                 cached: cache.get(node.path()).cloned(),
 337 
 338     fn spawn_token_worker(
 339         items: Vec<TokenWorkItem>,
 340         token_counter: Arc<dyn TokenCounterOperations>,
 341         sender: mpsc::Sender<TokenProgress>,
 343         let total_files = items.len();
 344         let available_threads = thread::available_parallelism()
 345             .map(|nz| nz.get())
 346             .unwrap_or(4);
 347         let pool_size = std::cmp::max(2, available_threads / 2);
 348         let pool: ThreadPool = ThreadPoolBuilder::new()
 349             .num_threads(pool_size)
 351             .build()
 352             .expect("Failed to build token worker thread pool");
 353 
 355             let mut processed: usize = 0;
 356             let mut buffered_entries: Vec<TokenProgressEntry> = Vec::new();
 357             let mut last_emit = Instant::now();
 358             let mut aborted = false;
 359 
 362                     break;
 364 
 365                 let chunk_results: Vec<TokenProgressEntry> = chunk
 366                     .par_iter()
 367                     .map(|item| process_work_item(item, &token_counter))
 368                     .collect();
 369 
 370                 processed += chunk.len();
 371                 buffered_entries.extend(chunk_results);
 372 
 373                 let now = Instant::now();
 374                 if now.duration_since(last_emit) >= PROGRESS_THROTTLE
 375                     && !buffered_entries.is_empty()
 377                     let entries_to_send = std::mem::take(&mut buffered_entries);
 379                         entries: entries_to_send,
 380                         files_processed: processed,
 381                         total_files,
 382                         is_final: false,
 385                         aborted = true;
 387                         last_emit = now;
 391 
 394                     entries: buffered_entries,
 395                     files_processed: processed,
 396                     total_files,
 397                     is_final: false,
 400                     aborted = true;
 403 
 406                     entries: Vec::new(),
 407                     files_processed: processed,
 408                     total_files,
 409                     is_final: true,
 414 
 415     // Helper: Collects (PathBuf, FileState) for a node and its children.
 416     fn collect_node_states_recursive(
 417         node: &FileNode,
 418         updates: &mut Vec<(PathBuf, SelectionState)>,
 420         updates.push((node.path().to_path_buf(), node.state()));
 423                 Self::collect_node_states_recursive(child, updates);
 427 
 428     /*
 429      * Recursively checks if the given node or any of its descendants is a file
 430      * in the 'New' state.
 431      */
 434             // It's a file
 435             return node.state() == SelectionState::New;
 437 
 438         // It's a directory, check its children
 441                 return true; // Found a new file in a descendant
 444         false // No new file found in this directory or its descendants
 446 
 447     #[cfg(test)]
 449         self.cached_file_token_details.clone()
 451 
 452     #[cfg(test)]
 454         self.cached_token_count
 457 
 460         self.profile_name.clone()
 462 
 464         self.profile_name = name;
 466 
 468         self.archive_path.clone()
 470 
 472         self.archive_path = path;
 474 
 476         self.root_path_for_scan.clone()
 478 
 480         self.exclude_patterns.clone()
 482 
 484         self.exclude_patterns = patterns;
 486 
 488         &self.file_system_snapshot_nodes
 490 
 492         self.file_system_snapshot_nodes = nodes;
 494 
 495     fn apply_selection_states_to_snapshot(
 496         &mut self,
 497         state_manager: &dyn NodeStateApplicatorOperations,
 498         selected_paths: &HashSet<PathBuf>,
 499         deselected_paths: &HashSet<PathBuf>,
 501         state_manager.apply_selection_states_to_nodes(
 502             &mut self.file_system_snapshot_nodes,
 503             selected_paths,
 504             deselected_paths,
 505         );
 507 
 509         Self::find_node_recursive_ref(&self.file_system_snapshot_nodes, path)
 510             .map(|node| (node.state(), node.is_dir()))
 512 
 513     fn update_node_state_and_collect_changes(
 514         &mut self,
 515         path: &Path,
 516         new_state: SelectionState,
 517         state_manager: &dyn NodeStateApplicatorOperations,
 519         let mut collected_changes = Vec::new();
 520         if let Some(node_to_update) =
 521             Self::find_node_recursive_mut(&mut self.file_system_snapshot_nodes, path)
 523             state_manager.update_folder_selection(node_to_update, new_state);
 524             // After updating, collect states from this node downwards
 525             Self::collect_node_states_recursive(node_to_update, &mut collected_changes);
 527             log::error!(
 529             );
 531         collected_changes
 533 
 534     /*
 535      * Checks if the file or folder at the given path, or any of its descendants
 536      * (if it's a folder), contains any file in the 'New' state.
 537      * This is used to determine if a folder node in the UI should display the "New" indicator.
 538      */
 540         log::trace!(
 542         );
 544             Some(node) => Self::does_node_contain_new_file_recursive(node),
 546                 log::warn!(
 548                 );
 549                 false
 553 
 554     /*
 555      * Use `get_token_count` for each selected file, which handles cache lookups,
 556      * file reads on miss/stale, and cache updates. The result is stored internally and returned.
 557      */
 558     fn update_total_token_count_for_selected_files(
 559         &mut self,
 560         token_counter: &dyn TokenCounterOperations,
 562         log::debug!("ProfileRuntimeData: Starting update_total_token_count_for_selected_files.");
 563 
 564         let mut total_tokens: usize = 0;
 565         let mut files_considered_for_total: usize = 0;
 566         let mut files_failed_to_get_count: usize = 0;
 567 
 568         // Recursive helper function.
 569         fn sum_tokens_recursive(
 570             nodes_to_scan: &[FileNode],
 571             token_counter_service: &dyn TokenCounterOperations,
 572             cache: &mut HashMap<PathBuf, FileTokenDetails>,
 573             current_total_tokens: &mut usize,
 574             processed_count: &mut usize,
 575             failed_count: &mut usize,
 579                     sum_tokens_recursive(
 580                         &node.children,
 581                         token_counter_service,
 582                         cache,
 583                         current_total_tokens,
 584                         processed_count,
 585                         failed_count,
 586                     );
 588                     *processed_count += 1;
 589                     if let Some(count) = ProfileRuntimeData::get_token_count_with_cache(
 590                         token_counter_service,
 591                         node,
 592                         cache,
 594                         *current_total_tokens += count;
 596                         *failed_count += 1;
 597                         log::warn!(
 599                             node.path()
 600                         );
 605 
 606         sum_tokens_recursive(
 607             &self.file_system_snapshot_nodes,
 608             token_counter,
 609             &mut self.cached_file_token_details, // Pass mutable cache
 610             &mut total_tokens,
 611             &mut files_considered_for_total,
 612             &mut files_failed_to_get_count,
 613         );
 614 
 615         self.cached_token_count = total_tokens;
 616         log::debug!(
 618             self.cached_token_count,
 619             files_considered_for_total,
 620             files_failed_to_get_count
 621         );
 622         self.cached_token_count
 624 
 625     fn recalc_tokens_async(
 626         &mut self,
 627         token_counter: Arc<dyn TokenCounterOperations>,
 628         only_selected: bool,
 630         let items = self.collect_token_work_items(only_selected);
 631         let total_files = items.len();
 632         self.cached_token_count = 0;
 634             return None;
 636 
 637         let (tx, rx) = mpsc::channel();
 638         let worker_counter = Arc::clone(&token_counter);
 639         let join_handle = thread::Builder::new()
 640             .name("token-recalc-worker".to_string())
 641             .spawn(move || Self::spawn_token_worker(items, worker_counter, tx))
 642             .expect("Failed to spawn token worker thread");
 643 
 645             receiver: rx,
 646             worker_handle: Some(join_handle),
 647             total_files,
 650 
 654                 self.cached_file_token_details.remove(&entry.path);
 656 
 658                 self.cached_file_token_details
 659                     .insert(entry.path.clone(), details);
 661 
 663                 self.cached_token_count = self.cached_token_count.saturating_add(entry.token_count);
 666         self.cached_token_count
 668 
 670         log::debug!("Clearing ProfileRuntimeData state.");
 671         self.profile_name = None;
 672         self.archive_path = None;
 673         self.file_system_snapshot_nodes.clear();
 674         self.root_path_for_scan = PathBuf::from("."); // Reset to default current directory
 675         self.cached_token_count = 0;
 676         self.cached_file_token_details.clear();
 677         self.exclude_patterns.clear();
 679 
 680     /*
 681      * Creates a `Profile` instance (a snapshot) from the current session state.
 682      * This is used when saving the current working state as a named profile.
 683      * It iterates through selected files in the current snapshot and uses
 684      * `self.cached_file_token_details` to populate the profile's `file_details`.
 685      * The `_token_counter` argument is not used if relying solely on the cache.
 686      */
 688         log::debug!(
 690             self.profile_name
 691         );
 692         let mut selected_paths_for_profile = HashSet::new();
 693         let mut deselected_paths_for_profile = HashSet::new();
 694         let mut file_details_for_save = HashMap::new(); // This will be populated
 695 
 696         // Recursive helper to gather selection states and populate file_details_for_save
 697         // from self.cached_file_token_details for selected files.
 698         fn gather_states_and_cached_details_recursive(
 699             nodes: &[FileNode],
 700             cached_details: &HashMap<PathBuf, FileTokenDetails>, // Read-only access to the current cache
 701             selected_paths_out: &mut HashSet<PathBuf>,
 702             deselected_paths_out: &mut HashSet<PathBuf>,
 703             file_details_out: &mut HashMap<PathBuf, FileTokenDetails>, // Populate this
 707                     // If the directory itself is marked selected/deselected, record its path.
 708                     // Children's states will be handled individually.
 711                             selected_paths_out.insert(node.path().to_path_buf());
 714                             deselected_paths_out.insert(node.path().to_path_buf());
 719                         gather_states_and_cached_details_recursive(
 720                             &node.children,
 721                             cached_details,
 722                             selected_paths_out,
 723                             deselected_paths_out,
 724                             file_details_out,
 725                         );
 728                     // It's a file
 731                             selected_paths_out.insert(node.path().to_path_buf());
 732                             // Only add details for selected files to file_details_out
 734                                 // We trust the cache. The checksum in `detail` is what we save.
 735                                 // `node.checksum` is the latest from disk, but we're saving the cached state.
 736                                 file_details_out.insert(node.path().to_path_buf(), detail.clone());
 737                                 log::trace!(
 739                                     node.path(),
 740                                     detail.checksum,
 741                                     detail.token_count
 742                                 );
 744                                 // If a selected file isn't in the cache, its details won't be saved.
 745                                 // This implies it might have been recently selected and not yet processed by
 746                                 // update_total_token_count, or get_token_count_with_cache failed for it.
 747                                 log::warn!(
 749                                     node.path()
 750                                 );
 754                             deselected_paths_out.insert(node.path().to_path_buf());
 761 
 762         gather_states_and_cached_details_recursive(
 763             &self.file_system_snapshot_nodes,
 764             &self.cached_file_token_details, // Provide read-only access to the current cache
 765             &mut selected_paths_for_profile,
 766             &mut deselected_paths_for_profile,
 767             &mut file_details_for_save,
 768         );
 769 
 771             name: self.profile_name.clone().unwrap_or_default(),
 772             root_folder: self.root_path_for_scan.clone(),
 773             selected_paths: selected_paths_for_profile,
 774             deselected_paths: deselected_paths_for_profile,
 775             archive_path: self.archive_path.clone(),
 776             file_details: file_details_for_save, // Use the selectively populated map
 777             exclude_patterns: self.exclude_patterns.clone(),
 780 
 781     /*
 782      * Activates the given profile: copies its data into `ProfileRuntimeData`,
 783      * loads its associated file system data, applies the profile's selection
 784      * state, updates token caches, and the total token count.
 785      * Returns `Ok(())` on success, or an `Err(String)` with an error message on failure.
 786      * TODO: The call to scan_directory() should be moved upwards.
 787      */
 788     fn load_profile_into_session(
 789         &mut self,
 790         loaded_profile: Profile,
 791         file_system_scanner: &dyn FileSystemScannerOperations,
 792         state_manager: &dyn NodeStateApplicatorOperations,
 793         _token_counter: &dyn TokenCounterOperations,
 795         log::debug!(
 797             loaded_profile.name
 798         );
 799         self.profile_name = Some(loaded_profile.name.clone());
 800         self.root_path_for_scan = loaded_profile.root_folder.clone();
 801         self.archive_path = loaded_profile.archive_path.clone();
 802         self.cached_file_token_details = loaded_profile.file_details.clone(); // Initial copy
 803         self.exclude_patterns = loaded_profile.exclude_patterns.clone();
 804 
 807                 self.file_system_snapshot_nodes = nodes;
 808                 log::debug!(
 810                     self.file_system_snapshot_nodes.len(),
 811                     self.profile_name
 812                 );
 813 
 814                 state_manager.apply_selection_states_to_nodes(
 815                     &mut self.file_system_snapshot_nodes,
 816                     &loaded_profile.selected_paths,
 817                     &loaded_profile.deselected_paths,
 818                 );
 819                 log::debug!(
 821                     self.profile_name
 822                 );
 823 
 824                 log::debug!(
 826                     self.profile_name
 827                 );
 828                 Ok(())
 831                 let error_message = format!(
 833                     self.root_path_for_scan, self.profile_name, e
 834                 );
 836                 self.clear(); // Clear all session data on scan failure
 837                 Err(error_message)
 841 
 843         let mut selected = HashSet::new();
 844         let mut deselected = HashSet::new();
 845         // Use your existing internal helper
 846         Self::gather_selected_deselected_paths_recursive_internal(
 847             &self.file_system_snapshot_nodes,
 848             &mut selected,
 849             &mut deselected,
 850         );
 851         (selected, deselected)
 854 
 855 #[cfg(test)]
 857     use super::*;
 858     use crate::core::checksum_utils;
 860         FileNode, FileSystemError, FileSystemScannerOperations, NodeStateApplicatorOperations,
 861         Profile, SelectionState, TokenCounterOperations,
 862         tokenizer_utils::SimpleWhitespaceTokenCounter,
 865     use std::fs;
 870 
 871     type ApplyProfileCallLog = (HashSet<PathBuf>, HashSet<PathBuf>, Vec<FileNode>);
 872 
 873     /*
 874      * This module contains unit tests for `ProfileRuntimeData` and its implementation
 875      * of `ProfileRuntimeDataOperations`. It focuses on testing session state management,
 876      * profile snapshot creation, token counting logic, and profile activation, using
 877      * mocks for external dependencies.
 878      */
 879 
 880     // --- Mock Structures for activate_and_populate_data ---
 882         scan_directory_results: Mutex<HashMap<PathBuf, Result<Vec<FileNode>, FileSystemError>>>,
 883         scan_directory_calls: Mutex<Vec<PathBuf>>,
 885 
 889                 scan_directory_results: Mutex::new(HashMap::new()),
 890                 scan_directory_calls: Mutex::new(Vec::new()),
 893 
 894         fn set_scan_directory_result(
 895             &self,
 896             path: &Path,
 897             result: Result<Vec<FileNode>, FileSystemError>,
 899             self.scan_directory_results
 900                 .lock()
 901                 .unwrap()
 902                 .insert(path.to_path_buf(), result);
 905 
 907         fn scan_directory(
 908             &self,
 909             root_path: &Path,
 910             exclude_patterns: &[String],
 912             let _ = exclude_patterns;
 913             self.scan_directory_calls
 914                 .lock()
 915                 .unwrap()
 916                 .push(root_path.to_path_buf());
 918                 Some(Ok(nodes)) => Ok(nodes.clone()),
 921                         FileSystemError::Io(io::Error::new(io_err.kind(), "mock io error"))
 923                     FileSystemError::IgnoreError(_) => FileSystemError::IgnoreError(
 924                         ignore::Error::from(io::Error::other("mock ignore error")),
 925                     ),
 926                     FileSystemError::InvalidPath(p) => FileSystemError::InvalidPath(p.clone()),
 928                 None => Ok(Vec::new()),
 932 
 934         apply_profile_to_tree_calls: Mutex<Vec<ApplyProfileCallLog>>,
 935         update_folder_selection_calls: Mutex<Vec<(PathBuf, SelectionState)>>,
 937 
 941                 apply_profile_to_tree_calls: Mutex::new(Vec::new()),
 942                 update_folder_selection_calls: Mutex::new(Vec::new()),
 945 
 947             self.apply_profile_to_tree_calls.lock().unwrap().clone()
 950             self.update_folder_selection_calls.lock().unwrap().clone()
 953 
 955         fn apply_selection_states_to_nodes(
 956             &self,
 957             tree: &mut Vec<FileNode>,
 958             selected_paths: &HashSet<PathBuf>,
 959             deselected_paths: &HashSet<PathBuf>,
 961             self.apply_profile_to_tree_calls.lock().unwrap().push((
 962                 selected_paths.clone(),
 963                 deselected_paths.clone(),
 964                 tree.clone(),
 965             ));
 966             // Simulate actual behavior for test consistency
 969                     node.set_state(SelectionState::Selected);
 971                     node.set_state(SelectionState::Deselected);
 973                     node.set_state(SelectionState::New);
 976                     self.apply_selection_states_to_nodes(
 977                         &mut node.children,
 978                         selected_paths,
 979                         deselected_paths,
 980                     );
 985             self.update_folder_selection_calls
 986                 .lock()
 987                 .unwrap()
 988                 .push((node.path().to_path_buf(), new_state));
 989             node.set_state(new_state);
 992                     self.update_folder_selection(child, new_state);
 997 
 998     // --- Mock TokenCounter ---
1000         default_count: usize,
1001         counts_for_content: HashMap<String, usize>,
1002         call_log: Mutex<Vec<String>>,
1007                 default_count,
1008                 counts_for_content: HashMap::new(),
1009                 call_log: Mutex::new(Vec::new()),
1014             self.counts_for_content.insert(content.to_string(), count);
1016 
1018             self.call_log.lock().unwrap().clone()
1021             self.call_log.lock().unwrap().clear();
1027             self.call_log.lock().unwrap().push(text.to_string());
1030                 *count
1032                 log::debug!(
1034                     text,
1035                     self.default_count
1036                 );
1037                 self.default_count
1041 
1042     fn create_temp_file_with_content(
1043         dir: &tempfile::TempDir,
1044         filename_prefix: &str,
1045         content: &str,
1047         let mut temp_file = tempfile::Builder::new()
1048             .prefix(filename_prefix)
1049             .suffix(".txt")
1050             .tempfile_in(dir.path())
1051             .unwrap();
1053         (temp_file.path().to_path_buf(), temp_file)
1055 
1056     #[test]
1058         // Arrange
1059         crate::initialize_logging();
1060 
1061         // Act
1062         let session_data = ProfileRuntimeData::new();
1063 
1064         // Assert
1065         assert!(session_data.profile_name.is_none());
1066         assert!(session_data.archive_path.is_none());
1067         assert!(session_data.cached_file_token_details.is_empty());
1068         assert!(session_data.file_system_snapshot_nodes.is_empty());
1069         assert_eq!(session_data.root_path_for_scan, PathBuf::from("."));
1070         assert_eq!(session_data.cached_token_count, 0);
1072 
1073     #[test]
1075         // Arrange
1076         crate::initialize_logging();
1077         let temp_dir = tempdir().unwrap();
1078         let file1_content_written = "content one";
1079         let (file1_path, _g1) =
1080             create_temp_file_with_content(&temp_dir, "f1", file1_content_written);
1081         let (file2_path, _g2) = create_temp_file_with_content(&temp_dir, "f2", "content two");
1082 
1084             profile_name: Some("OldProfile".to_string()),
1085             root_path_for_scan: temp_dir.path().join("new_root"),
1086             archive_path: Some(temp_dir.path().join("old_archive.zip")),
1087             file_system_snapshot_nodes: vec![
1088                 FileNode::new_full(
1089                     file1_path.clone(),
1090                     "file1.txt".into(),
1091                     false,
1092                     SelectionState::Selected,
1093                     Vec::new(),
1094                     "cs1".to_string(),
1095                 ),
1096                 FileNode::new_full(
1097                     file2_path.clone(),
1098                     "file2.txt".into(),
1099                     false,
1100                     SelectionState::Deselected,
1101                     Vec::new(),
1102                     "cs2".to_string(),
1103                 ),
1104             ],
1105             cached_token_count: 0, // Not directly used by create_profile_snapshot itself
1106             cached_file_token_details: HashMap::new(),
1107             exclude_patterns: Vec::new(),
1109         // Populate cached_file_token_details as update_total_token_count_for_selected_files would
1110         session_data.cached_file_token_details.insert(
1111             file1_path.clone(),
1113                 checksum: "cs1".to_string(), // Ensure this matches the FileNode's checksum if it's to be used
1114                 token_count: 10,
1116         );
1117 
1118         // Act
1119         let mut new_profile = session_data.create_profile_snapshot();
1120         new_profile.name = "NewProfile".to_string(); // Simulate renaming on save as
1121 
1122         // Assert
1123         assert_eq!(new_profile.name, "NewProfile");
1124         assert_eq!(new_profile.root_folder, temp_dir.path().join("new_root"));
1125         assert!(new_profile.selected_paths.contains(&file1_path));
1126         assert!(!new_profile.selected_paths.contains(&file2_path));
1127         assert!(new_profile.deselected_paths.contains(&file2_path));
1128         assert_eq!(
1129             new_profile.archive_path,
1130             Some(temp_dir.path().join("old_archive.zip"))
1131         );
1132         assert_eq!(
1133             new_profile.file_details.len(),
1134             1,
1135             "Only selected file should have details"
1136         );
1137         assert!(new_profile.file_details.contains_key(&file1_path));
1138         let detail1 = new_profile.file_details.get(&file1_path).unwrap();
1139         assert_eq!(detail1.checksum, "cs1");
1140         assert_eq!(detail1.token_count, 10);
1142 
1143     #[test]
1145         // Arrange
1146         crate::initialize_logging();
1147         let temp_dir = tempdir().unwrap();
1148         let content1 = "hello world";
1149         let (file1_path, _g1) = create_temp_file_with_content(&temp_dir, "f1", content1);
1150         let cs1 = "cs1_match".to_string();
1151 
1152         let content2 = "another example";
1153         let (file2_path, _g2) = create_temp_file_with_content(&temp_dir, "f2", content2);
1154         let cs2 = "cs2_match".to_string();
1155 
1156         let mut file_details_cache_for_session = HashMap::new();
1157         file_details_cache_for_session.insert(
1158             file1_path.clone(),
1160                 checksum: cs1.clone(),
1161                 token_count: 10,
1163         );
1164         file_details_cache_for_session.insert(
1165             file2_path.clone(),
1167                 checksum: cs2.clone(),
1168                 token_count: 20,
1170         );
1171 
1173             profile_name: Some("TestProfile".to_string()),
1174             root_path_for_scan: temp_dir.path().to_path_buf(),
1175             archive_path: None,
1176             cached_file_token_details: file_details_cache_for_session,
1177             file_system_snapshot_nodes: vec![
1178                 FileNode::new_full(
1179                     file1_path.clone(),
1180                     "f1.txt".into(),
1181                     false,
1182                     SelectionState::Selected,
1183                     Vec::new(),
1184                     cs1.clone(),
1185                 ),
1186                 FileNode::new_full(
1187                     file2_path.clone(),
1188                     "f2.txt".into(),
1189                     false,
1190                     SelectionState::Selected,
1191                     Vec::new(),
1192                     cs2.clone(),
1193                 ),
1194             ],
1195             cached_token_count: 0,
1196             exclude_patterns: Vec::new(),
1198         let mock_token_counter = MockTokenCounter::new(0); // Default, should not be used
1199 
1200         // Act
1201         let count = session_data.update_total_token_count_for_selected_files(&mock_token_counter);
1202 
1203         // Assert
1204         assert_eq!(count, 30, "Expected 10 (f1) + 20 (f2) from cache");
1205         assert_eq!(session_data.cached_token_count, 30);
1206         assert!(
1207             mock_token_counter.get_call_log().is_empty(),
1208             "Token counter should not be called on cache hits"
1209         );
1211 
1212     #[test]
1213     #[allow(unused_assignments)]
1215         crate::initialize_logging();
1216         let dir = tempdir().unwrap();
1217         let selected_path = dir.path().join("selected.txt");
1218         let unselected_path = dir.path().join("ignored.txt");
1219 
1220         fs::write(&selected_path, "alpha beta").unwrap();
1221         fs::write(&unselected_path, "gamma delta epsilon").unwrap();
1222 
1223         let selected_checksum = checksum_utils::calculate_sha256_checksum(&selected_path).unwrap();
1224         let unselected_checksum =
1225             checksum_utils::calculate_sha256_checksum(&unselected_path).unwrap();
1226 
1227         let mut selected_node = FileNode::new(
1228             selected_path.clone(),
1229             "selected.txt".into(),
1230             false,
1231             selected_checksum.clone(),
1232         );
1233         selected_node.set_state(SelectionState::Selected);
1234 
1235         let mut other_node = FileNode::new(
1236             unselected_path.clone(),
1237             "ignored.txt".into(),
1238             false,
1239             unselected_checksum,
1240         );
1241         other_node.set_state(SelectionState::Deselected);
1242 
1243         let mut session_data = ProfileRuntimeData::new();
1244         session_data.set_snapshot_nodes(vec![selected_node, other_node]);
1245         session_data.cached_file_token_details.insert(
1246             selected_path.clone(),
1248                 checksum: "stale".into(),
1249                 token_count: 42,
1251         );
1252 
1253         let token_counter: Arc<dyn TokenCounterOperations> = Arc::new(SimpleWhitespaceTokenCounter);
1255             receiver,
1256             worker_handle,
1257             total_files,
1259             .recalc_tokens_async(Arc::clone(&token_counter), true)
1260             .expect("Expected work items for selected files");
1261 
1262         assert_eq!(total_files, 1, "Only selected files should be processed");
1263 
1264         let mut final_total = 0usize;
1265         let mut saw_progress = false;
1267             let progress = receiver.recv().expect("Worker should send progress");
1268             let is_final = progress.is_final;
1269             let updated_total = session_data.apply_token_progress(progress);
1270             final_total = updated_total;
1271             saw_progress = true;
1273                 break;
1276 
1278             handle.join().expect("Worker thread should finish");
1280 
1281         assert!(
1282             saw_progress,
1283             "Expected at least one progress event in mock test"
1284         );
1285         assert_eq!(final_total, 2);
1286         assert_eq!(session_data.get_cached_total_token_count(), 2);
1287 
1288         let cache = session_data.get_cached_file_token_details();
1289         let entry = cache
1290             .get(&selected_path)
1291             .expect("Selected file should have cache entry");
1292         assert_eq!(entry.token_count, 2);
1293         assert_eq!(entry.checksum, selected_checksum);
1294         assert!(
1295             !cache.contains_key(&unselected_path),
1296             "Unselected file should not be recomputed when only_selected is true"
1297         );
1299 
1300     #[test]
1302         // Arrange
1303         crate::initialize_logging();
1304         let mut session_data = Box::new(ProfileRuntimeData::new());
1305         let mock_scanner = MockFileSystemScanner::new();
1306         let mock_state_manager = MockStateManager::new();
1307         let mut mock_token_counter = MockTokenCounter::new(0);
1308 
1309         let profile_name = "TestProfileDetailsUpdate";
1310         let temp_dir = tempdir().unwrap();
1311         let root_folder = temp_dir.path().to_path_buf();
1312 
1313         let content1 = "file one content"; // 10 tokens
1314         let (file1_path, _g1) = create_temp_file_with_content(&temp_dir, "f1", content1);
1315         let file1_checksum_disk = "cs1_disk_final".to_string();
1317 
1318         let content2 = "file two changed content"; // 20 tokens
1319         let (file2_path, _g2) = create_temp_file_with_content(&temp_dir, "f2", content2);
1320         let file2_checksum_disk = "cs2_disk_new_final".to_string();
1322 
1323         let mut initial_profile_file_details = HashMap::new();
1324         initial_profile_file_details.insert(
1325             file1_path.clone(),
1327                 checksum: file1_checksum_disk.clone(),
1328                 token_count: 10,
1330         );
1331         initial_profile_file_details.insert(
1332             file2_path.clone(),
1334                 checksum: "cs2_disk_old_stale".to_string(), // Stale checksum
1335                 token_count: 15,                            // Old token count
1337         );
1338 
1340             name: profile_name.to_string(),
1341             root_folder: root_folder.clone(),
1342             selected_paths: HashSet::new(),
1343             deselected_paths: HashSet::new(),
1344             archive_path: Some(PathBuf::from("/dummy/archive.txt")),
1345             file_details: initial_profile_file_details,
1346             exclude_patterns: Vec::new(),
1348         loaded_profile.selected_paths.insert(file1_path.clone());
1349         loaded_profile.selected_paths.insert(file2_path.clone());
1350 
1351         let nodes_from_scanner = vec![
1352             FileNode::new_full(
1353                 file1_path.clone(),
1354                 "f1.txt".into(),
1355                 false,
1356                 SelectionState::New, // Will be updated by apply_selection_states_to_nodes
1357                 Vec::new(),
1358                 file1_checksum_disk.clone(),
1359             ),
1360             FileNode::new_full(
1361                 file2_path.clone(),
1362                 "f2.txt".into(),
1363                 false,
1364                 SelectionState::New, // Will be updated
1365                 Vec::new(),
1366                 file2_checksum_disk.clone(), // New checksum on disk
1367             ),
1368         ];
1369         mock_scanner.set_scan_directory_result(&root_folder, Ok(nodes_from_scanner.clone()));
1370         mock_token_counter.clear_call_log();
1371 
1372         // Act
1373         let result = session_data.load_profile_into_session(
1374             loaded_profile.clone(),
1375             &mock_scanner,
1376             &mock_state_manager,
1377             &mock_token_counter,
1378         );
1379 
1380         // Assert
1381         assert!(result.is_ok());
1382         assert_eq!(
1383             session_data.get_profile_name().as_deref(),
1384             Some(profile_name)
1385         );
1386 
1387         // Verify that apply_selection_states_to_nodes was called and updated the states in snapshot_nodes
1388         let apply_calls = mock_state_manager.get_apply_profile_to_tree_calls();
1389         assert_eq!(apply_calls.len(), 1);
1390         let (selected_in_call, _, _) = &apply_calls[0];
1391         assert!(selected_in_call.contains(&file1_path));
1392         assert!(selected_in_call.contains(&file2_path));
1393 
1394         // After load_profile_into_session, the session_data.file_system_snapshot_nodes
1395         // should have their states (Selected/Deselected/New) correctly set by apply_selection_states_to_nodes.
1396         // Token recalculation is deferred, so cached file details remain as persisted in the profile.
1397 
1398         let session_details = session_data.get_cached_file_token_details();
1399         assert_eq!(session_details.get(&file1_path).unwrap().token_count, 10);
1400         assert_eq!(
1401             session_details.get(&file1_path).unwrap().checksum,
1402             file1_checksum_disk
1403         );
1404         // For file2, the stale profile entry remains until the async pipeline runs.
1405         assert_eq!(session_details.get(&file2_path).unwrap().token_count, 15);
1406         assert_eq!(
1407             session_details.get(&file2_path).unwrap().checksum,
1408             "cs2_disk_old_stale"
1409         );
1410         assert_eq!(session_data.get_cached_total_token_count(), 0);
1411         assert!(
1412             mock_token_counter.get_call_log().is_empty(),
1413             "Token counter should not run during load_profile_into_session"
1414         );
1416 
1417     #[test]
1419         // Arrange
1420         let mut session_data: ProfileRuntimeData = ProfileRuntimeData::new();
1421         let mock_state_manager = MockStateManager::new();
1422         let root_path = PathBuf::from("/root");
1423         let file1_path = root_path.join("file1.txt");
1424         let dir1_path = root_path.join("dir1");
1425         let file2_path = dir1_path.join("file2.txt");
1426 
1427         session_data.file_system_snapshot_nodes = vec![
1428             FileNode::new_full(
1429                 file1_path.clone(),
1430                 "file1.txt".into(),
1431                 false,
1432                 SelectionState::New,
1433                 Vec::new(),
1434                 "".to_string(),
1435             ),
1436             FileNode::new_full(
1437                 dir1_path.clone(),
1438                 "dir1".into(),
1439                 true,
1440                 SelectionState::New,
1441                 vec![FileNode::new_full(
1442                     file2_path.clone(),
1443                     "file2.txt".into(),
1444                     false,
1445                     SelectionState::New,
1446                     Vec::new(),
1447                     "".to_string(),
1448                 )],
1449                 "".to_string(),
1450             ),
1451         ];
1452 
1453         // Act: Select dir1 and its children
1454         let changes = session_data.update_node_state_and_collect_changes(
1455             &dir1_path,
1456             SelectionState::Selected,
1457             &mock_state_manager,
1458         );
1459 
1460         // Assert
1461         // Check MockStateManager calls
1462         let sm_calls = mock_state_manager.get_update_folder_selection_calls();
1463         assert_eq!(
1464             sm_calls.len(),
1465             2,
1466             "Expected StateManager to be called for dir1 and file2"
1467         );
1468         assert!(
1469             sm_calls
1470                 .iter()
1471                 .any(|(p, s)| p == &dir1_path && *s == SelectionState::Selected)
1472         );
1473         assert!(
1474             sm_calls
1475                 .iter()
1476                 .any(|(p, s)| p == &file2_path && *s == SelectionState::Selected)
1477         );
1478 
1479         // Check collected changes
1480         assert_eq!(changes.len(), 2, "Expected 2 changes collected");
1481         assert!(changes.contains(&(dir1_path.clone(), SelectionState::Selected)));
1482         assert!(changes.contains(&(file2_path.clone(), SelectionState::Selected)));
1483 
1484         // Verify internal state of ProfileRuntimeData reflects the change
1485         let dir1_node = ProfileRuntimeData::find_node_recursive_ref(
1486             &session_data.file_system_snapshot_nodes,
1487             &dir1_path,
1488         )
1489         .unwrap();
1490         assert_eq!(dir1_node.state(), SelectionState::Selected);
1491         let file2_node = ProfileRuntimeData::find_node_recursive_ref(
1492             &session_data.file_system_snapshot_nodes,
1493             &file2_path,
1494         )
1495         .unwrap();
1496         assert_eq!(file2_node.state(), SelectionState::Selected);
1497         let file1_node = ProfileRuntimeData::find_node_recursive_ref(
1498             &session_data.file_system_snapshot_nodes,
1499             &file1_path,
1500         )
1501         .unwrap();
1502         assert_eq!(file1_node.state(), SelectionState::New); // Should be unchanged
1504 
1505     #[test]
1507         // Arrange
1508         crate::initialize_logging();
1509         let temp_dir = tempdir().unwrap();
1510         let content_v1 = "version one content"; // 10 tokens (mocked)
1511         let content_v2 = "version two new content"; // 20 tokens (mocked)
1512 
1513         let (file_path, _g1) = create_temp_file_with_content(&temp_dir, "f_cache_test", content_v2);
1514         let checksum_v2 = checksum_utils::calculate_sha256_checksum(&file_path).unwrap();
1515 
1516         let mut mock_token_counter = MockTokenCounter::new(0);
1519 
1520         // Case 1: Cache Miss
1522             profile_name: Some("TestProfileMiss".to_string()),
1523             root_path_for_scan: temp_dir.path().to_path_buf(),
1524             archive_path: None,
1525             cached_file_token_details: HashMap::new(), // Empty cache -> miss
1526             file_system_snapshot_nodes: vec![FileNode::new_full(
1527                 file_path.clone(),
1528                 "f_cache_test.txt".into(),
1529                 false,
1530                 SelectionState::Selected,
1531                 Vec::new(),
1532                 checksum_v2.clone(), // Current checksum on disk
1533             )],
1534             cached_token_count: 0,
1535             exclude_patterns: Vec::new(),
1537         mock_token_counter.clear_call_log();
1538 
1539         // Act (Cache Miss)
1540         let total_miss =
1541             session_data_miss.update_total_token_count_for_selected_files(&mock_token_counter);
1542 
1543         // Assert (Cache Miss)
1544         assert_eq!(
1545             total_miss, 20,
1546             "Total count should be 20 for v2 content after miss"
1547         );
1548         assert_eq!(session_data_miss.cached_token_count, 20);
1549         assert_eq!(
1550             mock_token_counter.get_call_log().len(),
1551             1,
1552             "Token counter should be called once on cache miss"
1553         );
1554         assert!(
1555             mock_token_counter.get_call_log()[0].contains(content_v2),
1556             "Token counter should have processed v2 content"
1557         );
1558         let details_after_miss = session_data_miss.get_cached_file_token_details();
1559         assert!(
1560             details_after_miss.contains_key(&file_path),
1561             "Cache should now contain the file after miss"
1562         );
1563         let entry_miss = details_after_miss.get(&file_path).unwrap();
1564         assert_eq!(
1565             entry_miss.checksum, checksum_v2,
1566             "Cache checksum should be v2 after miss"
1567         );
1568         assert_eq!(
1569             entry_miss.token_count, 20,
1570             "Cache token count should be 20 after miss"
1571         );
1572 
1573         // Case 2: Stale Checksum
1574         let mut initial_stale_cache = HashMap::new();
1575         initial_stale_cache.insert(
1576             file_path.clone(),
1578                 checksum: "checksum_v1_stale".to_string(), // Stale checksum
1579                 token_count: 10,                           // Old token count for v1
1581         );
1583             profile_name: Some("TestProfileStale".to_string()),
1584             root_path_for_scan: temp_dir.path().to_path_buf(),
1585             archive_path: None,
1586             cached_file_token_details: initial_stale_cache, // Cache has stale entry
1587             file_system_snapshot_nodes: vec![FileNode::new_full(
1588                 file_path.clone(),
1589                 "f_cache_test.txt".into(),
1590                 false,
1591                 SelectionState::Selected,
1592                 Vec::new(),
1593                 checksum_v2.clone(), // Current checksum on disk is v2
1594             )],
1595             cached_token_count: 0,
1596             exclude_patterns: Vec::new(),
1598         mock_token_counter.clear_call_log();
1599 
1600         // Act (Stale Checksum)
1601         let total_stale =
1602             session_data_stale.update_total_token_count_for_selected_files(&mock_token_counter);
1603 
1604         // Assert (Stale Checksum)
1605         assert_eq!(
1606             total_stale, 20,
1607             "Total count should be 20 for v2 content after stale"
1608         );
1609         assert_eq!(session_data_stale.cached_token_count, 20);
1610         assert_eq!(
1611             mock_token_counter.get_call_log().len(),
1612             1,
1613             "Token counter should be called once on stale checksum"
1614         );
1615         assert!(
1616             mock_token_counter.get_call_log()[0].contains(content_v2),
1617             "Token counter should have processed v2 content on stale"
1618         );
1619         let details_after_stale = session_data_stale.get_cached_file_token_details();
1620         assert!(
1621             details_after_stale.contains_key(&file_path),
1622             "Cache should still contain the file after stale update"
1623         );
1624         let entry_stale = details_after_stale.get(&file_path).unwrap();
1625         assert_eq!(
1626             entry_stale.checksum, checksum_v2,
1627             "Cache checksum should be updated to v2 after stale"
1628         );
1629         assert_eq!(
1630             entry_stale.token_count, 20,
1631             "Cache token count should be updated to 20 after stale"
1632         );
1634 
1635     #[test]
1637         // Arrange
1638         let root_path = PathBuf::from("/root");
1639         let file1_new_path = root_path.join("file1_new.txt");
1640         let file2_selected_path = root_path.join("file2_selected.txt");
1641         let dir1_path = root_path.join("dir1");
1642         let file3_in_dir1_new_path = dir1_path.join("file3_new.txt");
1643         let dir2_path = root_path.join("dir2");
1644         let file4_in_dir2_selected_path = dir2_path.join("file4_selected.txt");
1645         let dir3_empty_path = root_path.join("dir3_empty");
1646         let dir4_deep_new_path = root_path.join("dir4_deep_new");
1647         let dir4_1_path = dir4_deep_new_path.join("subdir1");
1648         let dir4_2_path = dir4_1_path.join("subdir2");
1649         let file5_deep_new_path = dir4_2_path.join("file5_deep_new.txt");
1650 
1651         let mut data = ProfileRuntimeData::new();
1652         data.file_system_snapshot_nodes = vec![
1653             FileNode::new_full(
1654                 file1_new_path.clone(),
1655                 "file1_new.txt".into(),
1656                 false,
1657                 SelectionState::New,
1658                 Vec::new(),
1659                 "".to_string(),
1660             ),
1661             FileNode::new_full(
1662                 file2_selected_path.clone(),
1663                 "file2_selected.txt".into(),
1664                 false,
1665                 SelectionState::Selected,
1666                 Vec::new(),
1667                 "".to_string(),
1668             ),
1669             FileNode::new_full(
1670                 dir1_path.clone(),
1671                 "dir1".into(),
1672                 true,
1673                 SelectionState::New,
1674                 vec![FileNode::new_full(
1675                     file3_in_dir1_new_path.clone(),
1676                     "file3_new.txt".into(),
1677                     false,
1678                     SelectionState::New,
1679                     Vec::new(),
1680                     "".to_string(),
1681                 )],
1682                 "".to_string(),
1683             ),
1684             FileNode::new_full(
1685                 dir2_path.clone(),
1686                 "dir2".into(),
1687                 true,
1688                 SelectionState::New,
1689                 vec![FileNode::new_full(
1690                     file4_in_dir2_selected_path.clone(),
1691                     "file4_selected.txt".into(),
1692                     false,
1693                     SelectionState::Selected,
1694                     Vec::new(),
1695                     "".to_string(),
1696                 )],
1697                 "".to_string(),
1698             ),
1699             FileNode::new_full(
1700                 dir3_empty_path.clone(),
1701                 "dir3_empty".into(),
1702                 true,
1703                 SelectionState::New,
1704                 Vec::new(),
1705                 "".to_string(),
1706             ),
1707             FileNode::new_full(
1708                 dir4_deep_new_path.clone(),
1709                 "dir4_deep_new".into(),
1710                 true,
1711                 SelectionState::Selected,
1712                 vec![FileNode::new_full(
1713                     dir4_1_path.clone(),
1714                     "subdir1".into(),
1715                     true,
1716                     SelectionState::Selected,
1717                     vec![FileNode::new_full(
1718                         dir4_2_path.clone(),
1719                         "subdir2".into(),
1720                         true,
1721                         SelectionState::New,
1722                         vec![FileNode::new_full(
1723                             file5_deep_new_path.clone(),
1724                             "file5_deep_new.txt".into(),
1725                             false,
1726                             SelectionState::New,
1727                             Vec::new(),
1728                             "".to_string(),
1729                         )],
1730                         "".to_string(),
1731                     )],
1732                     "".to_string(),
1733                 )],
1734                 "".to_string(),
1735             ),
1736         ];
1737 
1738         // Act & Assert
1739         assert!(
1740             data.does_path_or_descendants_contain_new_file(&file1_new_path),
1741             "File 1 (New) should be true"
1742         );
1743         assert!(
1744             !data.does_path_or_descendants_contain_new_file(&file2_selected_path),
1745             "File 2 (Selected) should be false"
1746         );
1747 
1748         assert!(
1749             data.does_path_or_descendants_contain_new_file(&dir1_path),
1750             "Dir 1 (contains new file3) should be true"
1751         );
1752         assert!(
1753             data.does_path_or_descendants_contain_new_file(&file3_in_dir1_new_path),
1754             "File 3 (New, in dir1) should be true"
1755         );
1756 
1757         assert!(
1758             !data.does_path_or_descendants_contain_new_file(&dir2_path),
1759             "Dir 2 (contains selected file4) should be false"
1760         );
1761         assert!(
1762             !data.does_path_or_descendants_contain_new_file(&file4_in_dir2_selected_path),
1763             "File 4 (Selected, in dir2) should be false"
1764         );
1765 
1766         assert!(
1767             !data.does_path_or_descendants_contain_new_file(&dir3_empty_path),
1768             "Dir 3 (empty) should be false"
1769         );
1770 
1771         assert!(
1772             data.does_path_or_descendants_contain_new_file(&dir4_deep_new_path),
1773             "Dir 4 (contains deep new file5) should be true"
1774         );
1775         assert!(
1776             data.does_path_or_descendants_contain_new_file(&dir4_1_path),
1777             "Dir 4_1 (descendant contains new file5) should be true"
1778         );
1779         assert!(
1780             data.does_path_or_descendants_contain_new_file(&dir4_2_path),
1781             "Dir 4_2 (contains new file5) should be true"
1782         );
1783         assert!(
1784             data.does_path_or_descendants_contain_new_file(&file5_deep_new_path),
1785             "File 5 (New, deep) should be true"
1786         );
1787 
1788         assert!(
1789             !data.does_path_or_descendants_contain_new_file(&PathBuf::from("/non_existent_path")),
1790             "Non-existent path should be false"
1791         );
